REM   thbaby    11/16/17 - Bug 27131802: add snapshot interval to container$
REM   thbaby    11/13/17 - Bug 27083755: add sensitive_fixed$
REM   pjulsaks  09/26/17 - Bug 21563855: add flag to fed$app$status
REM   rankalik  09/14/17 - Include spares in connection_tests$
REM   pyam      05/16/17 - Bug 24524110: fwd merge of bug 21503951
REM   rankalik  04/27/17 - Add connection_tests$ table for draining
REM   tchorma   04/17/17 - Reserve obj$ number field for replication
REM   dmaniyan  02/07/17 - Reserve spare columns for sharding
REM   siyzhang  02/02/17 - Bug 25394846: add a new column to lockdown_prof$
REM   tchorma   02/01/17 - proj 47075 - Identity Column support for replication
REM   prshanth  01/22/17 - PROJ 70729: lockdown profile enhancements
REM   jaeblee   01/19/17 - Bug 25033818: add tenant_id to container$
REM   schakkap  01/09/17 - lrg 19868839: fix spare6 column of tab_stats$
REM   gravipat  12/22/16 - Bug 21902883: add pdb_snapshot$
REM   tianlli   12/14/16 - Bug 25177461: change the width of
REM                        proxy_remote$.remote_srvc
REM   prshanth  07/18/16 - Bug 23750190: add new columns to lockdown_prof$
REM   rrungta   05/25/16 - bug23300354: add HWM and flags to pdb_spfile$
REM   gravipat  05/17/16 - Bug 23104651: add postplugscn to container$
REM   thbaby    05/09/16 - Bug 23181611: support for crepatchid/modpatchid
REM   gravipat  04/08/16 - lrg 19284950: sql text should be clob in pdb_create$
REM   suresh    03/14/16 - Bug 22895916: Add appid# to pdb_sync_stmt$
REM   prshanth  03/09/16 - Bug 22904308: index change for lockdown profile
REM   thbaby    02/23/16 - Bug 22812470: add comment for USER$.SPARE10
REM   gravipat  02/18/16 - Bug 21858478: add blks to cdb_file$
REM   prshanth  02/17/16 - Bug 22686666: add timestamp to lockdown_prof$
REM   sankejai  02/05/16 - Bug 22622072: add cdb_props$
REM   pyam      02/03/16 - Bug 22373750: fix pdb_sync$ indexes
REM   pyam      01/07/16 - RTI 18894935: make i_pdbsync1 not unique
REM   acolunga  01/06/15 - Bug 22310234: add partobj$ flag for json vc 
REM                        partitioning
REM   thbaby    11/30/15 - Bug 21898184: add remote_user to proxy_remote$
REM   sankejai  11/24/15 - Bug 21947953: add pdbsvcstate$ and pdb_stat$
REM   thbaby    10/30/15 - Bug 21939181: support for app id/version
REM   aditigu   10/22/15 - Bug 21238674: Add new column to imsvc$
REM   ptearle   10/20/15 - Bug 22071869: correct spare1 flags in seg$
Rem   thbaby    10/08/15 - Bug 21971498: add proxy_remote$
Rem   aditigu   07/20/15 - Bug 21437329: adding index i_imsvc1, i_imsvcts1
REM   gravipat  07/13/15 - add table pdb_create$
REM   nrcorcor  07/13/15 - Bug 20865214 - newly added datafile not lw tracked
REM   prshanth  06/17/15 - Bug 21091902: add value$ to lockdown_prof$
REM   ddas      06/17/15 - proj 47170: persistent IMC statistics
REM   ssonawan  04/15/15 - Bug 20715920: add ext_username column to
REM                        cdb_local_adminauth$
REM   rmacnico  05/15/15 - Proj 47506
REM   gravipat  04/20/15 - Add new columns to cdb_file$
REM   rmacnico  04/15/15 - Proj 47506
REM   sdoraisw  04/15/15 - proj 47082- add partobj$ flag for external tables
REM   aditigu   04/01/15 - Add imsvc$, imorderby$ for inmemory metadata
REM   pyam      03/16/15 - 18764101 fwd merge: add pdb_inv_types$
REM   thbaby    03/02/15 - Proj 47234: remove property2 column of tab$
REM   gravipat  02/26/15 - Proj 47234: add new columns to container$
REM   thbaby    02/26/15 - Proj 47234: tgt_con_uid in view_pdb$
REM   sumkumar  02/25/15 - Bug 19895367: Store profile name in stead of
REM                        profile number in cdb_local_adminauth$ table
REM   gravipat  02/13/15 - Bug 20533616: make undoscn and lastrcvscn in
REM                        container$ to become one column
REM   gravipat  01/28/15 - Proj 47234: add table cdb_ts$
REM   huntran   01/20/15 - proj 58812: col$ and tab$ columns for auto CDR
Rem   prshanth  01/17/15 - Proj 47234: modify lockdown_prof$(option)
REM   prshanth  01/17/15 - Proj 47234: modify lockdown_prof$(option)
REM   molagapp  01/14/15 - Project 47808 - Restore from preplugin backup
REM   gravipat  12/30/14 - Proj 47234: add lastrcvscnwrp, lastrcvscnbas,
REM                        srcpdbuid columns to container$
REM   thbaby    12/04/14 - Proj 47234: add table view_pdb$
REM   thbaby    12/01/14 - Proj 47234: add remote_port to container$
REM   sasounda  11/20/14 - proj 47114: add new columns to partobj$
REM   thbaby    11/11/14 - Proj 47234: add containers_port, containers_host
REM   sankejai  11/04/14 - Bug 19946880: name in pdb_alert$ should be M_IDEN
REM   sasounda  10/22/14 - proj 47115: new val in partobj$.flags for autolist
REM   prshanth  10/12/14 - Proj 47234: add lockdown_prof$
REM   gravipat  09/08/14 - bug 19328303: add rafn# to container$
REM   jaeblee   07/22/14 - proj 47234: add undo switchover scn to container$
REM   thbaby    07/17/14 - Project 47234: add linkname, srcpdb to container$
REM   thbaby    07/17/14 - Project 47234: add linkname, srcpdb to container$
REM   awitkows  07/15/14 - Proj 47411: Local Temp Tblspcs. Take user$.spare9
REM   pyam      06/11/14 - fix pdb_alert$ column ordering
Rem   sankejai  06/06/14 - 18912837: use replay# in i_pdbsync1 index
REM   ssonawan  05/28/14 - Proj 46885: admin user password management
REM   wesmith   05/29/14 - Project 47511: data-bound collation
REM   cxie      05/15/14 - add CAUSE column to pdb_alert$
REM   akruglik  04/09/14 - Bug 18417322: add flags and a couple of spare 
REM                        columns to CDB_LOCAL_ADMINAUTH$
REM   pyam      03/05/14 - insert initial pdb_sync$ row
REM   gravipat  12/30/13 - add pdb_sync$
REM   cxie      10/16/13 - make index i_pdb_alert2 not unique
REM   smuthuli  08/08/13 - Preload prioritization support: Expand partobj$
REM   anthkim   12/01/02 - In-Memory Store: added imcflag_stg to deferred_stg$
REM   cxie      09/05/13 - add index i_pdb_alert2 on pdb_alert$
REM   cxie      06/11/13 - rename spare3 to vsn in container$
REM   thbaby    02/11/13 - Add cdbvw_stats$
REM   akruglik  01/20/13 - (BUG 14219716): create sequence PDB_ALERT_SEQUENCE 
REM   cxie      11/05/12 - add column status and action to pdb_alert$
REM   gravipat  10/25/12 - Add pdb_alert$
REM   gravipat  09/25/12 - Add foreign fields to cdb_file$
REM   acakmak   09/07/12 - Add constraint ep_repeat_count not null in histgrm$
REM   shase     08/21/12 - Add undohist$
REM   traney    06/28/12 - bug 14228510: increase max number of editions
REM   gravipat  08/03/12 - Add clonetag name to pdb_history$
REM   traney    06/28/12 - bug 14228510: increase max number of editions
REM   sanagara  07/31/12 - add spare columns to sqlerror$
REM   ssonawan  07/16/12 - bug 13843068: improve documentation of user$.astatus
REM   bhristov  04/16/12 - add flags to container$
REM   yuli      03/22/12 - bug 13573552: system default to force logging
REM   jkundu    03/08/12 - (bug 13615340): add always log group on seq$
Rem   sankejai  03/02/12 - 13254357: add pdb_spfile$
REM   akruglik  01/18/12 - (LRG 6689911): add cdb_local_adminauth$.passwd
REM   krajaman  12/12/11 - add rdba to container$ 
REM   akruglik  12/12/11 - update description of cdb_auth$, get rid of grantee#
REM   liaguo    11/18/11 - add comment for ts$.flags for ILM activity tracking
REM   bhristov  11/21/11 - Comment ts.flags KTT_BADTRANSPORT 
REM   akruglik  10/25/11 - cdb_auth$ and pdb_plug_in_violation$
REM   skayoor   10/17/11 - Bug 13077185: WITH GRANT OPTION for ON USER
REM   bhristov  10/10/11 - rename pdbdba$ to adminauth&
REM   bhristov  09/12/11 - add a column to pdbdba$
REM   cxie      08/30/11 - change pdb_history$.time to date
REM   akruglik  08/18/11 - change pdb_history$.operation to varchar2(16)
REM   kshergil  17/07/11 - Proj 30969: OLTP index compression
REM   ccaominh  08/26/11 - Proj 32743: Extend container$ for PDB open/close 
REM   amylavar  08/23/11 - Proj 30966: Add flag to TS$
REM   sankejai  08/11/11 - Move dependency$ after pseudo-bootstrap objects
REM   skayoor   06/27/11 - Project 32719 - Add INHERIT PRIVILEGES
REM   jmadduku  06/20/11 - Proj 32507: Use SPARE6 of USER$ to store LSLT
REM   wesmith   06/07/11 - project 31843: identity columns
REM   bhristov  07/12/11 - add pdbdba$
REM   kshergil  07/17/11 - Proj 30969: OLTP index compression
REM   jmadduku  20/06/11 - Proj 32507: Use SPARE6 of USER$ to store LSLT
REM   sankejai  05/09/11 - create pseudo-bootstrap objects after bootstrap$
REM   wesmith   04/28/11 - project 36891: add comments for col$.property bits
REM   weizhang  04/25/11 - add comment for 12g bigfile tbs in ts$ flags
REM   krajaman  04/09/11 - Extend container$
REM   skayoor   04/07/11 - Project 36360 - Add spare columns to user$
REM   traney    03/21/11 - 35209: long identifiers dictionary upgrade
REM   gravipat  12/10/09 - add pdb$
REM   gravipat  12/10/09 - add container$
REM   traney    01/06/11 - 35209: use M_IDEN_128 and M_IDEN_30
REM   gravipat  11/11/10 - add cdb_file$
REM   yifeng    04/04/10 - add comments to opqtype$ flags
REM   gravipat  10/15/09 - add sqlerror$
REM   rmacnico  04/14/09 - add comments for seg$, ts$ flag bits 
REM   shvenugo  03/19/09 - add comments to opqtype$ flags
REM   mbastawa  04/06/08 - add result cache for tab$.property
REM   schakrab  03/24/08 - add comments on obj$ flag
REM   mziauddi  01/25/08 - use spare2+spare3 of cdef$ for constraint ddl SCN
REM   ramekuma  03/13/08 - bug-6865413: add comments on i_obj2 index
REM   jaeblee   02/06/08 - add i_syn2
REM   bvaranas  01/30/08 - project 25274: Add deferred_stg$
REM   ssonawan  07/13/07 - bug-6020455: add comments on user$ table
REM   achoi     04/20/07 - add i_obj5
REM   sfeinste  04/09/07 - fix comments for type# column of obj$
REM   wechen    01/22/07 - fix comments for type# column of obj$
REM   krajaman  03/01/07 - add objerror$
REM   achoi     11/07/06 - obj$.spare3 stores base user#
REM   jaeblee   10/26/06 - moved edition$ creation from denv.bsq
REM   jiyang    09/07/06 - add comments for audit vault trigger
REM   akruglik  09/01/06 - replace CMV$ with EV$, CMVCOL$ with EVCOL$ + 
REM                        rename app_edition# with edition_obj#
REM   wechen    07/31/06 - add comments for type# column of obj$
REM   akruglik  04/07/06 - add EV$ and EVCOL$
REM   suelee    02/16/06 - bug 4956995 - moved objauth$ et al from dsec.bsq
REM   achoi     12/15/05 - tab$.trigflag 0x200000 indicates read-only table
REM   vmarwah   11/08/05 - Versioning Enabled flag in tab$
REM   jklein    08/01/05 - creation
create tablespace SYSTEM datafile "D_DBFN" 
  "D_DSTG" online
/
create rollback segment SYSTEM tablespace SYSTEM
  storage (initial 50K next 50K)
/
create cluster c_obj# (obj# number)
  pctfree 5 size 800                           /* don't waste too much space */
  /* A table of 32 cols, 2 index, 2 col per index requires about 2K.
   * A table of 10 cols, 2 index, 2 col per index requires about 750.
   */
  storage (initial 130K next 200k maxextents unlimited pctincrease 0) 
  /* avoid space management during IOR I */
/
create index i_obj# on cluster c_obj#
/
REM NOTE 
REM Logminer/Streams uses contents of this table. 
REM Please do not reuse any flags without verifying the impact of your 
REM changes on inter-op.  
create table tab$                                             /* table table */
( obj#          number not null,                            /* object number */
  /* DO NOT CREATE INDEX ON DATAOBJ#  AS IT WILL BE UPDATED IN A SPACE
   * TRANSACTION DURING TRUNCATE */
  dataobj#      number,                          /* data layer object number */
  ts#           number not null,                        /* tablespace number */
  file#         number not null,               /* segment header file number */
  block#        number not null,              /* segment header block number */
  bobj#         number,                /* base object number (cluster / iot) */
  tab#          number,    /* table number in cluster, NULL if not clustered */
  cols          number not null,                        /* number of columns */
  clucols       number,/* number of clustered columns, NULL if not clustered */
  pctfree$      number not null, /* minimum free space percentage in a block */
  pctused$      number not null, /* minimum used space percentage in a block */
  initrans      number not null,            /* initial number of transaction */
  maxtrans      number not null,            /* maximum number of transaction */
  flags         number not null, /* 0x00     = unmodified since last backup 
                                    0x01     = modified since then 
                                    0x02     = DML locks restricted to <= SX 
                                    0x04     = DML locks <= SX not acquired
                                    0x08     = CACHE  
                                    0x10     = table has been analyzed
                                    0x20     = table has no logging
                                    0x40     = 7.3 -> 8.0 data object
                                               migration required    
                                    0x0080   = current summary dependency
                                    0x0100   = user-specified stats
                                    0x0200   = global stats           
                                    0x0800   = table has security policy 
                                    0x020000 = Move Partitioned Rows 
                                   0x0400000 = table has sub tables
                                  0x00800000 = row dependencies enabled */
                /* 0x10000000 = this IOT has a  physical rowid mapping table */
                /* 0x20000000 = mapping table of an IOT(with physical rowid) */
  audit$        varchar2("S_OPFL") not null,             /* auditing options */
  rowcnt        number,                                    /* number of rows */
  blkcnt        number,                                  /* number of blocks */
  empcnt        number,                            /* number of empty blocks */
  avgspc        number,       /* average available free space/iot ovfl stats */
  chncnt        number,                            /* number of chained rows */
  avgrln        number,                                /* average row length */
  avgspc_flb    number,       /* avg avail free space of blocks on free list */
  flbcnt        number,                             /* free list block count */
  analyzetime   date,                        /* timestamp when last analyzed */
  samplesize    number,                 /* number of rows sampled by Analyze */
/* 
 * Legal values for degree, instances: 
 *     NULL (used to represent 1 on disk/dictionary and implies noparallel), or
 *     2 thru EB2MAXVAL-1 (user supplied values), or
 *     EB2MAXVAL (implies use default value) 
 */
  degree        number,      /* number of parallel query slaves per instance */
  instances     number,        /* number of OPS instances for parallel query */
/* <intcols> => the number of dictionary columns => the number of columns 
 * that have dictionary meta-data associated with them. This is a superset of 
 * <usercols> and <kernelcols>. 
 *    <intcols> = <kernelcols> + <number_of_virtual_columns>
 */
  intcols       number not null,               /* number of internal columns */
/* <kernelcols> => the number of REAL columns (ie) columns that actually
 * store data.
 */
  kernelcols    number not null,          /* number of REAL (kernel) columns */
  property      number not null,            /* table properties (bit flags): */
                              /* 0x01 = typed table, 0x02 = has ADT columns, */
                 /* 0x04 = has nested-TABLE columns, 0x08 = has REF columns, */
                      /* 0x10 = has array columns, 0x20 = partitioned table, */
               /* 0x40 = index-only table (IOT), 0x80 = IOT w/ row OVerflow, */
             /* 0x100 = IOT w/ row CLustering, 0x200 = IOT OVeRflow segment, */
               /* 0x400 = clustered table, 0x800 = has internal LOB columns, */
        /* 0x1000 = has primary key-based OID$ column, 0x2000 = nested table */
                    /* 0x4000 = View is Read Only, 0x8000 = has FILE columns */
       /* 0x10000 = obj view's OID is system-gen, 0x20000 = used as AQ table */
                                   /* 0x40000 = has user-defined lob columns */
                               /* 0x00080000 = table contains unused columns */
                            /* 0x100000 = has an on-commit materialized view */
                             /* 0x200000 = has system-generated column names */
                                      /* 0x00400000 = global temporary table */
                            /* 0x00800000 = session-specific temporary table */
                                        /* 0x08000000 = table is a sub table */
                                        /*   0x20000000 = pdml itl invariant */
                                          /* 0x80000000 = table is external  */
                          /* PFLAGS2: 0x400000000 = delayed segment creation */
  /* PFLAGS2: 0x20000000000 = result cache mode FORCE enabled on this table  */
  /* PFLAGS2: 0x40000000000 = result cache mode MANUAL enabled on this table */
  /* PFLAGS2: 0x80000000000 = result cache mode AUTO enabled on this table   */
  /* PFLAGS2: 0x400000000000000 = has identity column                        */
  trigflag      number,   /* first two bytes for trigger flags, the rest for */
                   /* general use, check tflags_kqldtvc in kqld.h for detail */
                                            /* 0x00000001 deferred RPC Queue */
                                                  /* 0x00000002 snapshot log */
                                        /* 0x00000004 updatable snapshot log */
                                             /* 0x00000008 = context trigger */
                                    /* 0x00000010 = synchronous change table */
                                             /* 0x00000020 = Streams trigger */
                                        /* 0x00000040 = Content Size Trigger */
                                         /* 0x00000080 = audit vault trigger */
                           /* 0x00000100 = Streams Auxiliary Logging trigger */
                     /* 0x00010000 = server-held key encrypted columns exist */
                       /* 0x00020000 = user-held key encrypted columns exist */
                                          /* 0x00200000 = table is read only */
                                     /* 0x00400000 = lobs use shared segment */
                                                 /* 0x00800000 = queue table */
                                   /* 0x10000000 = streams unsupported table */
                                            /* enabled at some point in past */
                            /* 0x80000000 = Versioning enabled on this table */
  spare1        number,                       /* used to store hakan_kqldtvc */
  spare2        number,         /* committed partition # used by drop column */
  spare3        number,                           /* summary sequence number */
  spare4        varchar2(1000),         /* committed RID used by drop column */
  spare5        varchar2(1000),      /* summary related information on table */
  spare6        date,                                 /* flashback timestamp */
  spare7        number,
  spare8        number,
  spare9        varchar2(1000),
  spare10       varchar2(1000),
  acdrflags     number,                                    /* auto cdr flags */
                                         /* 0x00000001 = auto cdr configured */
                                     /* 0x00000002 = column-level resolution */
                          /* 0x00000004 = delete tombstone enabled for table */
                       /* 0x00000008 = table is a delete tombstone log table */
  acdrtsobj#    number,                              /* tombstone table obj$ */
  acdrdefaulttime  timestamp,                       /* auto cdr default time */
  acdrrowtsintcol# number                 /* intcol# for row-level timestamp */
)
cluster c_obj#(obj#)
/  
create table clu$                                           /* cluster table */
( obj#          number not null,                            /* object number */
  /* DO NOT CREATE INDEX ON DATAOBJ#  AS IT WILL BE UPDATED IN A SPACE
   * TRANSACTION DURING TRUNCATE */
  dataobj#      number,                          /* data layer object number */
  ts#           number not null,                        /* tablespace number */
  file#         number not null,               /* segment header file number */
  block#        number not null,              /* segment header block number */
  cols          number not null,                        /* number of columns */
  pctfree$      number not null, /* minimum free space percentage in a block */
  pctused$      number not null, /* minimum used space percentage in a block */
  initrans      number not null,            /* initial number of transaction */
  maxtrans      number not null,            /* maximum number of transaction */
  size$         number,
       /* if b-tree, estimated number of bytes for each cluster key and rows */
  hashfunc      varchar2("M_IDEN"),        /* if hashed, function identifier */

  /* Some of the spare columns may give the initial # bytes in the hash table
   * and the # hash keys per block.  These are user-specified parameters.
   * For extendible hash tables, two columns might include the # bits
   * currently be used in the hash function and the number of the next
   * bucket to split.
   * Some spare columns may be used for hash table statistics
   * such as # distinct keys, # distinct values of first key column, and
   * average # blocks per key.  Some spare columns  may give the number of
   * the cluster table for which the cluster key is unique or indicate
   * whether the cluster is normal or referential.
   * We can encode multiple pieces of info in a single column.
   */
  hashkeys      number,                                    /* hash key count */
  func          number, /* function: 0 (key is function), 1 (system default) */
  extind        number,             /* extent index value of fixed hash area */
  flags         number,                                      /* 0x08 = CACHE */
                                          /* 0x010000 = Single Table Cluster */
                                                /* 0x00800000 = DEPENDENCIES */
/* 
 * Legal values for degree, instances: 
 *     NULL (used to represent 1 on disk/dictionary and implies noparallel), or
 *     2 thru EB2MAXVAL-1 (user supplied values), or
 *     EB2MAXVAL (implies use default value) 
 */
  degree        number,      /* number of parallel query slaves per instance */
  instances     number,       /*  number of OPS instances for parallel query */
  avgchn        number,          /* average chain length - previously spare4 */
  spare1        number,                /* used for trigger non-trigger flags */
                                                          /* 0x1 replication */
                                                         /* 0x2 snapshot log */
                                                             /* 0x4 snapshot */
                                             /* 0x8 context internal trigger */
                                            /* 0x10 synchronous change table */
                             /* 0x00010000 One or more columns are encrypted */
                                   /*    0x00020000 All columns are encrypted*/
                                           /* 0x00040000 needs to do logging */
                                                   /* 0x00080000 MV Dataless */
                                   /* 0x00100000 IOT transient table for PMO */
                                                            /* 0x00200000 MPR*/
                                        /* 0x00400000  QUEue organized table */
  spare2        number,
  spare3        number,
  spare4        number,
  spare5        varchar2(1000),
  spare6        varchar2(1000),
  spare7        date
)
cluster c_obj#(obj#)
/
create cluster c_ts#(ts# number)           /* use entire block for each ts# */
/
create index i_ts# on cluster c_ts#
/
create cluster c_file#_block#(ts# number, segfile# number, segblock# number) 
  size 225    /* cluster key ~ 25, sizeof(seg$) ~ 50, 5 * sizeof(uet$) ~ 150 */
  storage (initial 20K)               /* avoid space management during IOR I */
/
create index i_file#_block# on cluster c_file#_block#
/
create cluster c_user#(user# number) 
  size  372 /* cluster key ~ 20, sizeof(user$) ~ 227, 5 * sizeof(tsq$) ~ 125 */
/
create index i_user# on cluster c_user#
/
create table fet$                                       /* free extent table */
( ts#           number not null,        /* tablespace containing free extent */
  file#         number not null,              /* file containing free extent */
  block#        number not null,              /* starting dba of free extent */
  length        number not null           /* length in blocks of free extent */
)
cluster c_ts#(ts#)
/
create table uet$                                       /* used extent table */
( segfile#      number not null,               /* segment header file number */
  segblock#     number not null,              /* segment header block number */
  ext#          number not null,         /* extent number within the segment */
  ts#           number not null,        /* tablespace containing this extent */
  file#         number not null,              /* file containing this extent */
  block#        number not null,              /* starting dba of this extent */
  length        number not null           /* length in blocks of this extent */
)
cluster c_file#_block#(ts#, segfile#, segblock#)
/
create table seg$                                           /* segment table */
( file#         number not null,               /* segment header file number */
  block#        number not null,              /* segment header block number */
  type#         number not null,                /* segment type (see KTS.H): */
   /* 1 = UNDO, 2 = SAVE UNDO, 3 = TEMPORARY, 4 = CACHE, 5 = DATA, 6 = INDEX */
   /* 7 = SORT  8 = LOB   9 = Space Header 10 = System Managed Undo          */
  ts#           number not null,       /* tablespace containing this segment */
  blocks        number not null,       /* blocks allocated to segment so far */
                                           /* zero for bitmapped tablespaces */
  extents       number not null,      /* extents allocated to segment so far */
                                           /* zero for bitmapped tablespaces */
  iniexts       number not null,                      /* initial extent size */
  minexts       number not null,                /* minimum number of extents */
  maxexts       number not null,                /* maximum number of extents */
  extsize       number not null,                 /* current next extent size */
                                           /* zero for bitmapped tablespaces */
  extpct        number not null,                    /* percent size increase */
  user#         number not null,               /* user who owns this segment */
  lists         number,                        /* freelists for this segment */
  /* For SECUREFILE LOBs, reuse as RETENTION attribute                       */
  /* one of 1) AUTO - 1 2) NONE - 2 3) MIN - 3 4) MAX - 4                    */
  groups        number,                  /* freelist groups for this segment */
  /* For next gen lobs, reuse as MIN RETENTION */
  bitmapranges  number not null,                 /* ranges per bit map entry */
                             /* reuse as MAXSIZE for 11g compatible segments */
  cachehint     number not null,                        /* hints for caching */
  scanhint      number not null,                       /* hints for scanning */
                                       /* Reuse it as inc# for ASSM segments */
  hwmincr       number not null,             /* Amount by which HWM is moved */
                                          /* Reuse it as object number/class */
                                     /* for objects in bitmapped tablespaces */
  spare1        number,                        /* Segment flags - NULL = 0x0 */
                    /* 0x1 - bitmapped tablespace: KTSSEGM_FLAG_BITMAPPED_TS */
                                 /* 0x2 - undo segment: KTSSEGM_FLAG_UNDOSEG */
                           /* 0x4 - saveundo segment: KTSSEGM_FLAG_SVUNDOSEG */
                       /* 0x8 - segment marked corrupt: KTSSEGM_FLAG_CORRUPT */
                                     /* 0x0010 - KTSSEGM_FLAG_BEING_MIGRATED */
                                     /* 0x0020 - KTSSEGM_FLAG_BMAPHDR_SEG    */
                                     /* 0x0040 - KTSSEGM_FLAG_BLKSFILLED     */
                                     /* 0x0080 - KTSSEGM_FLAG_NOQUOTA        */
                                     /* 0x0100 - KTSSEGM_FLAG_PAGETABLE      */
                                     /* 0x0200 - KTSSEGM_FLAG_TEMPOBJ        */
                                     /* 0x0400 - KTSSEGM_FLAG_OBJDEFINED     */
                                     /* 0x0800 - KTSSEGM_FLAG_COMPRESSED     */
                                     /* 0x1000 - KTSSEGM_FLAG_HASCPRSSED     */
                                     /* 0x2000 - KTSSEGM_FLAG_ROWMOVEMNT     */
                                     /* 0x4000 - KTSSEGM_FLAG_HASMOVEMNT     */
             /*0x10000 - segment flushed from cache: KTSSEGM_FLAG_RECYCLEBIN */
            /* 0x40000 - 11gR1 HSC Compressed Segment:  KTSSEGM_FLAG_NEW_HSC */
               /* 0x080000 - 11gR1 LZO Compressed Segment:  KTSSEGM_FLAG_LZO */
               /* 0x100000 - 11gR1 ZLIB Compressed Segmnt: KTSSEGM_FLAG_ZLIB */
               /* 0x200000 - Next generation LOB segment: KTSSEGM_FLAG_NGLOB */
               /* 0x400000 - Segment has MAXSIZE set:  KTSSEGM_FLAG_MAXSZSET */
               /* 0x800000 - Encrypted segment:             KTSSEGM_FLAG_ENC */
              /* 0x1000000 - OLTP Compressed:             KTSSEGM_FLAG_OLTP  */
              /* 0x2000000 - Columnar Compressed low:     KTSSEGM_FLAG_ARCH1 */
              /* 0x4000000 - Columnar Compressed high:    KTSSEGM_FLAG_ARCH2 */
              /* 0x8000000 - Columnar Compressed archive: KTSSEGM_FLAG_ARCH3 */
             /* 0x10000000 - Read mostly segment:    KTSSEGM_FLAG_READMOSTLY */
             /* 0x40000000 - Large Extents:        KTSSEGM_FLAG_LARGE_EXTENT */
  spare2        number
)
cluster c_file#_block#(ts#, file#, block#)
/
create table undo$                                     /* undo segment table */
( us#           number not null,                      /* undo segment number */
  name          varchar2("M_IDEN_30") not null, /* name of this undo segment */
  user#         number not null,      /* owner: 0 = SYS(PRIVATE), 1 = PUBLIC */
  file#         number not null,               /* segment header file number */
  block#        number not null,              /* segment header block number */
  scnbas        number,           /* highest commit time in rollback segment */
  scnwrp        number,              /* scnbas - scn base, scnwrp - scn wrap */
  xactsqn       number,               /* highest transaction sequence number */
  undosqn       number,                /* highest undo block sequence number */
  inst#         number,    /* parallel server instance that owns the segment */
  status$       number not null,              /* segment status (see KTS.H): */
  /* 1 = INVALID, 2 = AVAILABLE, 3 = IN USE, 4 = OFFLINE, 5 = NEED RECOVERY, 
   * 6 = PARTLY AVAILABLE (contains in-doubt txs) 
   */
  ts#           number,                                 /* tablespace number */
  ugrp#         number,                      /* The undo group it belongs to */
  keep          number,
  optimal       number,
  flags         number,
  spare1        number,
  spare2        number,
  spare3        number,
  spare4        varchar2(1000),
  spare5        varchar2(1000),
  spare6        date
)

/
REM NOTE 
REM Logminer/Streams uses contents of this table. 
REM Please do not reuse any flags without verifying the impact of your 
REM changes on inter-op.  
create table ts$                                         /* tablespace table */
( ts#           number not null,             /* tablespace identifier number */
  name          varchar2("M_IDEN_30") not null,        /* name of tablespace */
  owner#        number not null,                      /* owner of tablespace */
  online$       number not null,                      /* status (see KTT.H): */
                                     /* 1 = ONLINE, 2 = OFFLINE, 3 = INVALID */
  contents$     number not null,     /* TEMPORARY/PERMANENT                  */
  undofile#     number,  /* undo_off segment file number (status is OFFLINE) */
  undoblock#    number,               /* undo_off segment header file number */
  blocksize     number not null,                   /* size of block in bytes */
  inc#          number not null,             /* incarnation number of extent */
  scnwrp        number,     /* clean offline scn - zero if not offline clean */
  scnbas        number,              /* scnbas - scn base, scnwrp - scn wrap */
  dflminext     number not null,       /*  default minimum number of extents */
  dflmaxext     number not null,        /* default maximum number of extents */
  dflinit       number not null,              /* default initial extent size */
  dflincr       number not null,                 /* default next extent size */
  dflminlen     number not null,              /* default minimum extent size */
  dflextpct     number not null,     /* default percent extent size increase */
  dflogging     number not null,
      /* lowest bit: default logging attribute: clear=NOLOGGING, set=LOGGING */
                                    /* second lowest bit: force logging mode */
  affstrength   number not null,                        /* Affinity strength */
  bitmapped     number not null,       /* If not bitmapped, 0 else unit size */
                                                                /* in blocks */
  plugged       number not null,                               /* If plugged */
  directallowed number not null,   /* Operation which invalidate standby are */
                                                                  /* allowed */
  flags         number not null,                /* various flags: see ktt3.h */
                                         /* 0x01 = system managed allocation */
                                         /* 0x02 = uniform allocation        */
                                /* if above 2 bits not set then user managed */
                                         /* 0x04 = migrated tablespace       */
                                         /* 0x08 = tablespace being migrated */
                                         /* 0x10 = undo tablespace           */
                                     /* 0x20 = auto segment space management */
                       /* if above bit not set then freelist segment managed */
                                                          /* 0x40 = COMPRESS */
                                                      /* 0x80 = ROW MOVEMENT */
                                                              /* 0x100 = SFT */
                                         /* 0x200 = undo retention guarantee */
                                    /* 0x400 = tablespace belongs to a group */
                                  /* 0x800 = this actually describes a group */
                                      /* 0x10000 = OLTP Compression          */
                                      /* 0x20000 = Columnar Low Compression  */
                                      /* 0x40000 = Columnar High Compression */
                                      /* 0x80000 = Archive Compression       */
                                        /* 0x100000 = 12g bigfile tablespace */
                                        /* 0x200000 = DB Consol. Shared TS   */
                                        /* 0x800000 =     ILM policy present */
                                   /* 0x1000000 = bad transport of ts in pdb */
                                 /* 0x2000000 = ILM segment access tracking  */
                                 /* 0x4000000 = ILM row access tracking      */
                                 /* 0x8000000 = ILM update activity tracking */
                                /* 0x10000000 = ILM create activity tracking */
                                                  /* 0x800000000002 = SHARED */
 /* 0x1000000000040=DEF_INDEX_COMPRESSION(KTT_COMPRESSED||KTT_IDX_COMPRESSED)*/
       /* 0x1000000000000 and 0x6000000000000 and F0000 = INDEX_COMPRESS_FOR */
                                        /* 0xF80000000000000 = DEF_CELLCACHE */
                           /* 0x1000000000000000 LOST_WRITE_PROTECT ENABLED  */
                            /* 0x2000000000000000 LOST_WRITE_PROTECT SUSPEND */
  pitrscnwrp    number,                      /* scn wrap when ts was created */
  pitrscnbas    number,                      /* scn base when ts was created */
  ownerinstance varchar("M_IDEN_30"),                 /* Owner instance name */
  backupowner   varchar("M_IDEN_30"),          /* Backup owner instance name */
  groupname     varchar("M_IDEN_30"),                          /* Group name */
  spare1        number,                                  /* plug-in SCN wrap */
  spare2        number,                                  /* plug-in SCN base */
  spare3        varchar2(1000),
  spare4        date
)
cluster c_ts#(ts#)
/
create table file$                                             /* file table */
( file#         number not null,                   /* file identifier number */
  status$       number not null,                      /* status (see KTS.H): */
                                               /* 1 = INVALID, 2 = AVAILABLE */
  blocks        number not null,                   /* size of file in blocks */
                                           /* zero for bitmapped tablespaces */
  ts#           number,                         /* tablespace that owns file */
  relfile#      number,                              /* relative file number */
  maxextend     number,                                 /* maximum file size */
  inc           number,                                  /* increment amount */
  crscnwrp      number,                                 /* creation SCN wrap */
  crscnbas      number,                                 /* creation SCN base */
  ownerinstance varchar("M_IDEN_30"),                 /* Owner instance name */
  spare1        number,      /* tablespace-relative DBA of space file header */
                                   /* NULL for dictionary-mapped tablespaces */
  spare2        number,                                       /* flags field */ 
                                           /* 0x1 LOST_WRITE_PROTECT enabled */
                               /* 0x2 LOST_WRITE_PROTECT suspend (suspended) */
                                
  spare3        varchar2(1000),
  spare4        date
)
/
REM NOTE 
REM Logminer/Streams uses contents of this table. 
REM Please do not reuse any flags without verifying the impact of your 
REM changes on inter-op.  
create table obj$                                            /* object table */
( obj#          number not null,                            /* object number */
  dataobj#      number,                          /* data layer object number */
  owner#        number not null,                        /* owner user number */
  name          varchar2("M_IDEN") not null,                  /* object name */
  namespace     number not null,         /* namespace of object (see KQD.H): */
 /* 1 = TABLE/PROCEDURE/TYPE, 2 = BODY, 3 = TRIGGER, 4 = INDEX, 5 = CLUSTER, */
                                                  /* 8 = LOB, 9 = DIRECTORY, */
  /* 10 = QUEUE, 11 = REPLICATION OBJECT GROUP, 12 = REPLICATION PROPAGATOR, */
                                     /* 13 = JAVA SOURCE, 14 = JAVA RESOURCE */
                                                 /* 58 = (Data Mining) MODEL */
  subname       varchar2("M_IDEN"),               /* subordinate to the name */
  type#         number not null,                 /* object type (see KQD.H): */
  /* 1 = INDEX, 2 = TABLE, 3 = CLUSTER, 4 = VIEW, 5 = SYNONYM, 6 = SEQUENCE, */
             /* 7 = PROCEDURE, 8 = FUNCTION, 9 = PACKAGE, 10 = NON-EXISTENT, */
              /* 11 = PACKAGE BODY, 12 = TRIGGER, 13 = TYPE, 14 = TYPE BODY, */
      /* 19 = TABLE PARTITION, 20 = INDEX PARTITION, 21 = LOB, 22 = LIBRARY, */
                                             /* 23 = DIRECTORY , 24 = QUEUE, */
    /* 25 = IOT, 26 = REPLICATION OBJECT GROUP, 27 = REPLICATION PROPAGATOR, */
    /* 28 = JAVA SOURCE, 29 = JAVA CLASS, 30 = JAVA RESOURCE, 31 = JAVA JAR, */
                 /* 32 = INDEXTYPE, 33 = OPERATOR , 34 = TABLE SUBPARTITION, */
                                                  /* 35 = INDEX SUBPARTITION */
                                                 /* 82 = (Data Mining) MODEL */
                                /* 92 = OLAP CUBE DIMENSION,  93 = OLAP CUBE */
                   /* 94 = OLAP MEASURE FOLDER, 95 = OLAP CUBE BUILD PROCESS */
  ctime         date not null,                       /* object creation time */
  mtime         date not null,                      /* DDL modification time */
  stime         date not null,          /* specification timestamp (version) */
  status        number not null,            /* status of object (see KQD.H): */
                                     /* 1 = VALID/AUTHORIZED WITHOUT ERRORS, */
                          /* 2 = VALID/AUTHORIZED WITH AUTHORIZATION ERRORS, */
                            /* 3 = VALID/AUTHORIZED WITH COMPILATION ERRORS, */
                         /* 4 = VALID/UNAUTHORIZED, 5 = INVALID/UNAUTHORIZED */
  remoteowner   varchar2("M_IDEN"),     /* remote owner name (remote object) */
  linkname      varchar2("M_XDBI"),             /* link name (remote object) */
  flags         number,               /* 0x01 = extent map checking required */
                                      /* 0x02 = temporary object             */
                                      /* 0x04 = system generated object      */
                                      /* 0x08 = unbound (invoker's rights)   */
                                      /* 0x10 = secondary object             */
                                      /* 0x20 = in-memory temp table         */
                                      /* 0x80 = dropped table (RecycleBin)   */
                                      /* 0x100 = synonym VPD policies        */
                                      /* 0x200 = synonym VPD groups          */
                                      /* 0x400 = synonym VPD context         */
                                      /* 0x4000 = nested table partition     */
  oid$          raw(16),        /* OID for typed table, typed view, and type */
  spare1        number,                      /* sql version flag: see kpul.h */
  spare2        number,                             /* object version number */
  spare3        number,                                        /* base user# */
  spare4        varchar2(1000),
  spare5        varchar2(1000),
  spare6        date,
  signature     raw(16),                      /* object signature hash value */
  spare7        number,                          /* reserved for replication */
  spare8        number,                                        /* future use */
  spare9        number,
  dflcollid     number,                   /* unit-level default collation id */
  creappid      number,         /* App ID of Application that created object */
  creverid      number,        /* Version of Application that created object */
  crepatchid    number,       /* Patch ID of Application that created object */
  modappid      number,   /* App ID of Application that last modified object */
  modverid      number,  /* Version of Application that last modified object */
  modpatchid    number, /* Patch ID of Application that last modified object */
  spare10       number,
  spare11       number,
  spare12       varchar2(1000),
  spare13       varchar2(1000),
  spare14       timestamp
)
  storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/
REM NOTE 
REM Logminer/Streams uses contents of this table. 
REM Please do not reuse any flags without verifying the impact of your 
REM changes on inter-op.  
create table ind$                                             /* index table */
( obj#          number not null,                            /* object number */
  /* DO NOT CREATE INDEX ON DATAOBJ#  AS IT WILL BE UPDATED IN A SPACE
   * TRANSACTION DURING TRUNCATE */
  dataobj#      number,                          /* data layer object number */
  ts#           number not null,                        /* tablespace number */
  file#         number not null,               /* segment header file number */
  block#        number not null,              /* segment header block number */
  bo#           number not null,              /* object number of base table */
  indmethod#    number not null,    /* object # for cooperative index method */
  cols          number not null,                        /* number of columns */
  pctfree$      number not null, /* minimum free space percentage in a block */
  initrans      number not null,            /* initial number of transaction */
  maxtrans      number not null,            /* maximum number of transaction */
  pctthres$     number,           /* iot overflow threshold, null if not iot */
  type#         number not null,              /* what kind of index is this? */
                                                               /* normal : 1 */
                                                               /* bitmap : 2 */
                                                              /* cluster : 3 */
                                                            /* iot - top : 4 */
                                                         /* iot - nested : 5 */
                                                            /* secondary : 6 */
                                                                 /* ansi : 7 */
                                                                  /* lob : 8 */
                                             /* cooperative index method : 9 */
  flags         number not null,      
                /* mutable flags: anything permanent should go into property */
                                                    /* unusable (dls) : 0x01 */
                                                    /* analyzed       : 0x02 */
                                                    /* no logging     : 0x04 */
                                    /* index is currently being built : 0x08 */
                                     /* index creation was incomplete : 0x10 */
                                           /* key compression enabled : 0x20 */
                                              /* user-specified stats : 0x40 */
                                            /* secondary index on IOT : 0x80 */
                                      /* index is being online built : 0x100 */
                                    /* index is being online rebuilt : 0x200 */
                                                /* index is disabled : 0x400 */
                                                     /* global stats : 0x800 */
                                            /* fake index(internal) : 0x1000 */
                                       /* index on UROWID column(s) : 0x2000 */
                                            /* index with large key : 0x4000 */
                             /* move partitioned rows in base table : 0x8000 */
                                 /* index usage monitoring enabled : 0x10000 */
                      /* 4 bits reserved for bitmap index version : 0x1E0000 */
                                            /* index is invisible : 0x200000 */
                                       /* Delayed Segment Creation: 0x400000 */
                                              /* index is partial : 0x800000 */
                                                   /* 2 free bits: 0x3000000 */
                                      /* Delayed Segment Creation: 0x4000000 */
                                    /* online index cleanup phase: 0x8000000 */
                                   /* index has orphaned entries: 0x10000000 */
                                 /* index is going to be dropped: 0x20000000 */
                                 /* oltp high index compression : 0x40000000 */
                                   /* oltp low index compression: 0x80000000 */
  property      number not null,    /* immutable flags for life of the index */
                                                            /* unique : 0x01 */
                                                       /* partitioned : 0x02 */
                                                           /* reverse : 0x04 */
                                                        /* compressed : 0x08 */
                                                        /* functional : 0x10 */
                                              /* temporary table index: 0x20 */
                             /* session-specific temporary table index: 0x40 */
                                              /* index on embedded adt: 0x80 */
                         /* user said to check max length at runtime: 0x0100 */
                                              /* domain index on IOT: 0x0200 */
                                                      /* join index : 0x0400 */
                                     /* system managed domain index : 0x0800 */
                           /* The index was created by a constraint : 0x1000 */
                              /* The index was created by create MV : 0x2000 */
                                          /* composite domain index : 0x8000 */
  /* The following columns are used for index statistics such
   * as # btree levels, # btree leaf blocks, # distinct keys, 
   * # distinct values of first key column, average # leaf blocks per key,
   * clustering info, and # blocks in index segment.
   */
  blevel        number,                                       /* btree level */
  leafcnt       number,                                  /* # of leaf blocks */
  distkey       number,                                   /* # distinct keys */
  lblkkey       number,                          /* avg # of leaf blocks/key */
  dblkkey       number,                          /* avg # of data blocks/key */
  clufac        number,                                 /* clustering factor */
  analyzetime   date,                        /* timestamp when last analyzed */
  samplesize    number,                 /* number of rows sampled by Analyze */
  rowcnt        number,                       /* number of rows in the index */
  intcols       number not null,               /* number of internal columns */
         /* The following two columns are only valid for partitioned indexes */
/* 
 * Legal values for degree, instances: 
 *     NULL (used to represent 1 on disk/dictionary and implies noparallel), or
 *     2 thru EB2MAXVAL-1 (user supplied values), or
 *     EB2MAXVAL (implies use default value) 
 */
  degree        number,      /* number of parallel query slaves per instance */
  instances     number,       /*  number of OPS instances for parallel query */

  trunccnt      number,                        /* re-used for iots 'inclcol' */
  evaledition#  number,                                /* evaluation edition */
  unusablebefore#    number,                      /* unusable before edition */
  unusablebeginning# number,              /* unusable beginning with edition */
  spare1        number,         /* number of columns depended on, >= intcols */
  spare2        number,        /* number of key columns in compressed prefix */
  spare3        number,
  spare4        varchar2(1000),     /* used for parameter str for domain idx */
  spare5        varchar2(1000),
  spare6        date                                  /* flashback timestamp */
)
cluster c_obj#(bo#)
/
REM NOTE 
REM Logminer/Streams uses contents of this table. 
REM Please do not reuse any flags without verifying the impact of your 
REM changes on inter-op.  
create table icol$                                     /* index column table */
( obj#          number not null,                      /* index object number */
  bo#           number not null,                       /* base object number */
  col#          number not null,                            /* column number */
  pos#          number not null,        /* column position number as created */
  segcol#       number not null,                 /* column number in segment */
  segcollength  number not null,             /* length of the segment column */
  offset        number not null,                         /* offset of column */
  intcol#       number not null,                   /* internal column number */
  spare1        number,                                              /* flag */
                                              /* 0x01: this is an expression */
                                                  /* 0x02: desc index column */
                                          /* 0x04: filter by col for dom idx */
                                           /* 0x08: order by col for dom idx */
  spare2        number,            /* dimension table internal column number */
  spare3        number,           /* pos# of col in order by list of dom idx */
  spare4        varchar2(1000),
  spare5        varchar2(1000),
  spare6        date
)
cluster c_obj#(bo#)
/
REM NOTE 
REM Logminer/Streams uses contents of this table. 
REM Please do not reuse any flags without verifying the impact of your 
REM changes on inter-op.  
create table col$                                            /* column table */
( obj#          number not null,             /* object number of base object */
  col#          number not null,                 /* column number as created */
  segcol#       number not null,                 /* column number in segment */
  segcollength  number not null,             /* length of the segment column */
  offset        number not null,                         /* offset of column */
  name          varchar2("M_IDEN") not null,               /* name of column */
  type#         number  not null,                     /* data type of column */
                                           /* for ADT column, type# = DTYADT */
  length        number  not null,               /* length of column in bytes */
  fixedstorage  number  not null,   /* flags: 0x01 = fixed, 0x02 = read-only */
  precision#    number,                                         /* precision */
  scale         number,                                             /* scale */
  null$         number not null,                     /* 0 = NULLs permitted, */
                                                /* > 0 = no NULLs permitted  */
  deflength     number,              /* default value expression text length */
  default$      long,                       /* default value expression text */

  /*
   * If a table T(c1, addr, c2) contains an ADT column addr which is stored 
   * exploded, the table will be internally stored as 
   *              T(c1, addr, C0003$, C0004$, C0005$, c2)
   * Of these, only c1, addr and c2 are user visible columns. Thus, the 
   * user visible column numbers for (c1, addr, C0003$, C0004$, C0005$, c2) 
   * will be 1,2,0,0,0,3. And the corresponding internal column numbers will 
   * be 1,2,3,4,5,6. 
   *
   * Some dictionary tables like icol$, ccol$ need to contain intcol# so 
   * that we can have indexes and constraints on ADT attributes. Also, these
   * tables also need to contain col# to maintain backward compatibility.
   * Most of these tables will need to be accessed by col#, intcol# so 
   * indexes are created on them based on (obj#, col#) and (obj#, intcol#).
   * Indexes based on col# have to be non-unique if ADT attributes might
   * appear in the table. Indexes based on intcol# can be unique.
   */
  intcol#       number not null,                   /* internal column number */
  property      number not null,           /* column properties (bit flags): */
                /* 0x0001 =       1 = ADT attribute column                   */
                /* 0x0002 =       2 = OID column                             */
                /* 0x0004 =       4 = nested table column                    */
                /* 0x0008 =       8 = virtual column                         */
                /* 0x0010 =      16 = nested table's SETID$ column           */
                /* 0x0020 =      32 = hidden column                          */
                /* 0x0040 =      64 = primary-key based OID column           */
                /* 0x0080 =     128 = column is stored in a lob              */
                /* 0x0100 =     256 = system-generated column                */
                /* 0x0200 =     512 = rowinfo column of typed table/view     */
                /* 0x0400 =    1024 = nested table columns setid             */
                /* 0x0800 =    2048 = column not insertable                  */
                /* 0x1000 =    4096 = column not updatable                   */
                /* 0x2000 =    8192 = column not deletable                   */
                /* 0x4000 =   16384 = dropped column                         */
                /* 0x8000 =   32768 = unused column - data still in row      */
            /* 0x00010000 =   65536 = virtual column                         */
            /* 0x00020000 =  131072 = place DESCEND operator on top          */
            /* 0x00040000 =  262144 = virtual column is NLS dependent        */
            /* 0x00080000 =  524288 = ref column (present as oid col)        */
            /* 0x00100000 = 1048576 = hidden snapshot base table column      */
            /* 0x00200000 = 2097152 = attribute column of a user-defined ref */
            /* 0x00400000 = 4194304 = export hidden column,RLS on hidden col */
            /* 0x00800000 = 8388608 = string column measured in characters   */
           /* 0x01000000 = 16777216 = virtual column expression specified    */
           /* 0x02000000 = 33554432 = typeid column                          */
           /* 0x04000000 = 67108864 = Column is encrypted                    */
          /* 0x20000000 = 536870912 = Column is encrypted without salt       */
        
      /* 0x000800000000 = 34359738368 = default with sequence                */
      /* 0x001000000000 = 68719476736 = default on null                      */
      /* 0x002000000000 = 137438953472 = generated always identity column    */
      /* 0x004000000000 = 274877906944 = generated by default identity col   */
      /* 0x080000000000 = 8796093022208 = Column is sensitive                */

  /* The spares may be used as the column's NLS character set, 
   * the number of distinct column values, and the column's domain.
   */
  /* the universal character set id maintained by NLS group */
  charsetid     number,                              /* NLS character set id */
  /*
   * charsetform
   */
  charsetform   number,
  /* 1 = implicit: for CHAR, VARCHAR2, CLOB w/o a specified set */
  /* 2 = nchar: for NCHAR, NCHAR VARYING, NCLOB */
  /* 3 = explicit: for CHAR, etc. with "CHARACTER SET ..." clause */
  /* 4 = flexible: for PL/SQL "flexible" parameters */
  evaledition#  number,                                /* evaluation edition */
  unusablebefore#    number,                      /* unusable before edition */
  unusablebeginning# number,              /* unusable beginning with edition */
  spare1        number,                      /* fractional seconds precision */
  spare2        number,                  /* interval leading field precision */
  spare3        number,            /* maximum number of characters in string */
  spare4        varchar2(1000),          /* NLS settings for this expression */
  spare5        varchar2(1000),
  spare6        date,
  spare7        number,
  spare8        number,
  collid        number,                                      /* collation id */
  collintcol#   number,           /* reference to the actual collated column */
       /* if a virtual column is created to implement collation, this column */
       /* will be populated to refer to the user collated column             */
  spare9        number,                 /* column position in a sharding key */
  spare10       number,             /* column position in a partitionset key */
  spare11       varchar2(1000),
  spare12       varchar2(1000),
  spare13       timestamp,
  acdrrescol#   number                        /* auto cdr resolution intcol# */
)
cluster c_obj#(obj#)
/
REM NOTE 
REM Logminer/Streams uses contents of this table. 
REM Please do not reuse any flags without verifying the impact of your 
REM changes on inter-op.  
create table user$                                             /* user table */
( user#         number not null,                   /* user identifier number */
  name          varchar2("M_IDEN") not null,                 /* name of user */
               /* 0 = role, 1 = user, 2 = adjunct schema, 3 = schema synonym */
  type#         number not null,
  password      varchar2(4000),                        /* encrypted password */
  datats#       number not null, /* default tablespace for permanent objects */
  tempts#       number not null,  /* default tablespace for temporary tables */
  ctime         date not null,                 /* user account creation time */
  ptime         date,                                /* password change time */
  exptime       date,                     /* actual password expiration time */
  ltime         date,                         /* time when account is locked */
  resource$     number not null,                        /* resource profile# */
  audit$        varchar2("S_OPFL"),                    /* user audit options */
  defrole       number not null,                  /* default role indicator: */
               /* 0 = no roles, 1 = all roles granted, 2 = roles in defrole$ */
  defgrp#       number,                                /* default undo group */
  defgrp_seq#   number,               /* global sequence number for  the grp */
  astatus       number default 0 not null,          /* status of the account */
                /* 0x00 =       0 = Open                                     */
                /* 0x01 =       1 = Expired                                  */
                /* 0x02 =       2 = Expired(GRACE)                           */
                /* 0x04 =       4 = Locked(TIMED)                            */
                /* 0x05 =       5 = Expired & Locked(TIMED)                  */
                /* 0x06 =       6 = Expired(GRACE) & Locked(TIMED)           */
                /* 0x08 =       8 = Locked                                   */
                /* 0x09 =       9 = Expired & Locked                         */
                /* 0x0A =      10 = Expired(GRACE) & Locked                  */
                /* 0x10 =      16 = Password matches a default value         */
  lcount        number default 0 not null, /* count of failed login attempts */
  defschclass   varchar2("M_IDEN"),                /* initial consumer group */
  ext_username  varchar2("M_VCSZ"),                     /* external username */
                             /* also as base schema name for adjunct schemas */
  spare1        number, /* used for schema level supp. logging: see ktscts.h */
  /* spare2 is used to store                                                 */
  /* - edition id for adjunct schemas (type# = 2)                            */
  /* - base schema id for schema synonyms (type# = 3)                        */
  spare2        number,      
  spare3        number,           /* used for schema-level default collation */
  spare4        varchar2(1000),
  spare5        varchar2(1000),
  spare6        date,                 /* used for Last Successful Logon Time */
  spare7        varchar2(4000),
  spare8        varchar2(4000),
  spare9        number,               /* default local temporaty tablespace  */
  spare10       number,                           /* Creation Application ID */
  spare11       timestamp
)
cluster c_user#(user#)
/
create table proxy_data$
( client#            NUMBER NOT NULL,                      /* client user ID */
  proxy#             NUMBER NOT NULL,                       /* proxy user ID */
  credential_type#   NUMBER NOT NULL,  /* Type of credential passed by proxy */
                   /*
                    * Values
                    * 0 = No credential
                    * 1 = Certificate
                    * 2 = Distinguished Name
                    * 4 = Oracle password
                    */
  credential_version# NUMBER NOT NULL,   /* Version number of the credential */
                   /*
                    * Values
                    * 0 = no version
                    * If certificate:
                    * 1 = X.509 V3
                    */
  credential_minor# NUMBER NOT NULL,      /* Minor credential version number */
                   /*
                    * Values
                    * 0 = no version
                    * If certificate:
                    * 1 = V3
                    */
  flags               NUMBER NOT NULL /* Mask flags of associated with entry */
             /* Flags values:
              * 1 = proxy can activate all client roles
              * 2 = proxy can activate no client roles
              * 4 = role can be activated by proxy,
              * 8 = role cannot be activated by proxy
              */
)
/
create unique index i_proxy_data$ on proxy_data$(client#, proxy#)
/
create table proxy_role_data$
( client#       NUMBER NOT NULL,                           /* client user ID */
  proxy#        NUMBER NOT NULL,                            /* proxy user ID */
  role#         NUMBER NOT NULL                                   /* role ID */
)
/
create index i_proxy_role_data$_1 on 
  proxy_role_data$(client#, proxy#)
/
create unique index i_proxy_role_data$_2 on 
  proxy_role_data$(client#, proxy#, role#)
/
create table con$                                        /* constraint table */
( owner#        number not null,                        /* owner user number */
  name          varchar2("M_IDEN") not null,              /* constraint name */
  con#          number not null,                        /* constraint number */
  spare1        number,         /* used for online add constraint. see kqd.h */
  spare2        number,
  spare3        number,
  spare4        varchar2(1000),
  spare5        varchar2(1000),
  spare6        date
)
/
create cluster c_cobj# (obj# number)
  pctfree 0 pctused 50
  /* space for: update cdef$ set condition = 'col IS NOT NULL' at // */
  size 300
  storage (initial 50K)               /* avoid space management during IOR I */
/
create index i_cobj# on cluster c_cobj#
/
REM NOTE 
REM Logminer/Streams uses contents of this table. 
REM Please do not reuse any flags without verifying the impact of your 
REM changes on inter-op.  
create table cdef$                            /* constraint definition table */
( con#          number not null,                        /* constraint number */
  obj#          number not null,         /* object number of base table/view */
  cols          number,                   /* number of columns in constraint */
  type#         number not null,                         /* constraint type: */
                 /* Note: If new types are added then please ensure that the */
                 /* {....}_CONSTRAINTS family of views reflect the new type. */
                            /* 1 = table check, 2 = primary key, 3 = unique, */
                             /* 4 = referential, 5 = view with CHECK OPTION, */
                                                 /* 6 = view READ ONLY check */
               /* 7 - table check constraint associated with column NOT NULL */
                                   /* 8 - hash expressions for hash clusters */
                                         /* 9 - Scoped REF column constraint */
                                    /* 10 - REF column WITH ROWID constraint */
                                  /* 11 - REF/ADT column with NOT NULL const */
                                 /* 12 - Log Groups for supplemental logging */
                                 /* 13 - Allow PKref vals Storage in REF col */
                                    /* 14 - Primary key supplemental logging */
                                     /* 15 - Unique key supplemental logging */
                                    /* 16 - Foreign key supplemental logging */
                                     /* 17 - All column supplemental logging */
  robj#         number,                 /* object number of referenced table */
  rcon#         number,           /* constraint number of referenced columns */
  rrules        varchar2(3),         /* future: use this columns for pendant */
  match#        number,                /* referential constraint match type: */
                                                 /* null = FULL, 1 = PARTIAL */
        /* this column can also store information for other constraint types */
  refact        number,                               /* referential action: */
              /* null = RESTRICT, 1 = CASCADE, 2 = SET NULL, 3 = SET DEFAULT */
  enabled        number,          /* is constraint enabled? NULL if disabled */
  condlength    number,                 /* table check condition text length */
  condition     long,                          /* table check condition text */
  intcols       number,          /* number of internal columns in constraint */
  mtime         date,      /* date this constraint was last enabled-disabled */
  defer         number,                     /* 0x01 constraint is deferrable */
                                              /* 0x02 constraint is deferred */
                                /* 0x04 constraint has been system validated */
                                 /* 0x08 constraint name is system generated */
                       /* 0x10 constraint is BAD, depends on current century */
                           /* 0x20, optimizer should RELY on this constraint */
                                             /* 0x40 Log Group ALWAYS option */
                                /* 0x80 (view related) constraint is invalid */
                                       /* 0x100 constraint depends on a view */
                            /* 0x200 constraint is a partitioning constraint */
                              /* 0x400 referenced by partitioning constraint */
                             /* 0x800 constraint is a valid time  constraint */
  spare1        number,                      /* sql version flag: see kpul.h */
  spare2        number,            /* create/last modify constraint SCN wrap */
  spare3        number,            /* create/last modify constraint SCN base */
  spare4        varchar2(1000),
  spare5        varchar2(1000),
  spare6        date
)
cluster c_cobj#(obj#)
/
REM NOTE 
REM Logminer/Streams uses contents of this table. 
REM Please do not reuse any flags without verifying the impact of your 
REM changes on inter-op.  
create table ccol$                                /* constraint column table */
( con#          number not null,                        /* constraint number */
  obj#          number not null,                       /* base object number */
  col#          number not null,                            /* column number */
  pos#          number,                 /* column position number as created */
  intcol#       number not null,                   /* internal column number */
  spare1        number,                 /* Constarint specific column flags  */
                                          /* 0x1  NO LOG Supplemental column */
  spare2        number,
  spare3        number,
  spare4        varchar2(1000),
  spare5        varchar2(1000),
  spare6        date
)
cluster c_cobj#(obj#)
/
create index i_tab1 on tab$(bobj#)
/
create unique index i_undo1 on undo$(us#)
/
create index i_undo2 on undo$(name)
/
create unique index i_obj1 on obj$(obj#, owner#, type#)
/
REM NOTE 
REM Partitioning uses this index critically. 
REM Please don't modify this index without verifying the impact of your 
REM changes on partitioning.
create unique index i_obj2 on obj$(owner#, name, namespace, remoteowner,
linkname, subname, type#, spare3, obj#)
  storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/
create index i_obj3 on obj$(oid$)
/
create index i_obj4 on obj$(dataobj#, type#, owner#)
/
create unique index i_obj5 on obj$(spare3, name, namespace, type#, owner#,
remoteowner, linkname, subname, obj#)
/
create unique index i_ind1 on ind$(obj#)
/
create index i_icol1 on icol$(obj#)
/
create unique index i_file1 on file$(file#)
/
create unique index i_file2 on file$(ts#, relfile#)
/
create unique index i_ts1 on ts$(name)
/
create unique index i_user1 on user$(name)
/
create unique index i_user2 on user$(user#, type#, spare1, spare2)
/
create unique index i_col1 on col$(obj#, name)
  storage (initial 30k next 100k maxextents unlimited pctincrease 0)
/
create index i_col2 on col$(obj#, col#)
  storage (initial 30k next 100k maxextents unlimited pctincrease 0)
/
create unique index i_col3 on col$(obj#, intcol#)
  storage (initial 30k next 100k maxextents unlimited pctincrease 0)
/
create unique index i_con1 on con$(owner#, name)
/
create unique index i_con2 on con$(con#)
/
create unique index i_cdef1 on cdef$(con#)
/
create index i_cdef2 on cdef$(obj#)
/
create index i_cdef3 on cdef$(robj#)
/
create index i_cdef4 on cdef$(enabled)
/
create index i_ccol1 on ccol$(con#, col#)
/
create unique index i_ccol2 on ccol$(con#, intcol#)
/
create table bootstrap$
( line#         number not null,                       /* statement order id */
  obj#          number not null,                            /* object number */
  sql_text      varchar2("M_VCSZ") not null)                    /* statement */
  storage (initial 50K)            /* to avoid space management during IOR I */
//                                            /* "//" required for bootstrap */

REM Create a table to track objects that compile with errors, i.e. status 2 or
REM 3. Since the -ve dependencies are removed (KGLTNEXS) we have to invalidate
REM all objects in status 2 or 3 because we don't why they are in that state.
REM We ended up doing a FTS on obj$ for every object creation, which is very 
REM expensive. To reduce this expense we are creating this table which will
REM contain all objects that are compiled with errors.
REM Name of the table - objerror$

create table objerror$
(
  obj#          number not null                            /* object number */
)
  segment creation immediate
/

REM
REM PSEUDO-BOOTSTRAP OBJECTS
REM ========================
REM There should be no objects added after bootstrap$ and before these 
REM pseudo-bootstrap objects are created (except objerror$ above).
REM Only pseudo-bootstrap objects (as defined in kqlb.c) can be defined
REM in the section below. All pseudo-bootstrap tables and indexes should 
REM explicitly specify "segment creation immediate" clause for supporting
REM Deferred Segment Creation for SEED Pluggable Database in 
REM Consolidated Database.
REM

REM
REM Create objauth$ and related tables early.  
REM If tables or indicies are aged out of the shared pool before objauth$
REM is created, then subsequent references to these objects result in ORA-942.
REM See bugs 4956995 and 3477195.
REM
create table objauth$                           /* table authorization table */
( obj#          number not null,                            /* object number */
  grantor#      number not null,                      /* grantor user number */
  grantee#      number not null,                      /* grantee user number */
  privilege#    number not null,                   /* table privilege number */
  sequence#     number not null,                    /* unique grant sequence */
  parent        rowid,                                             /* parent */
  option$       number,                                 /* null = no options */
                                                      /* 0x01 = grant option */
                                                  /* 0x02 = hierarchy option */
                          /* 0x04 = tuple represents ONLY a Common Privilege */
                                                  /* 0x08 = Common Privilege */
                                /* 0x10 = Common Privilege with grant option */
                            /* 0x20 = Common Privilege with hierarchy option */
  col#          number)     /* null = table level, column id if column grant */
  segment creation immediate
/
create unique index i_objauth1 on 
  objauth$(obj#, grantor#, grantee#, privilege#, col#)
/
create index i_objauth2 on objauth$(grantee#, obj#, col#)
/

Rem Cluster for Histograms 
Rem This is to make access to histogram for a column faster.
create cluster c_obj#_intcol#
( obj#            number,                                   /* object number */
  intcol#         number)                          /* internal column number */
  pctfree 5
  storage (initial 2m next 200k maxextents unlimited pctincrease 0)
/
create index i_obj#_intcol# on cluster c_obj#_intcol#
  storage (maxextents unlimited)
/

Rem Histograms
create table histgrm$                                     /* histogram table */
( obj#            number not null,                          /* object number */
  col#            number not null,                          /* column number */
  row#            number,                       /* row number (in row cache) */
  bucket          number not null,                          /* bucket number */
  endpoint        number not null,                  /* endpoint hashed value */
  intcol#         number not null,                 /* internal column number */
  epvalue         varchar2(1000),              /* endpoint value information */
  ep_repeat_count number default 0 not null,    /* frequency of the endpoint */
  epvalue_raw     raw(1000),                           /* endpoint raw value */
  spare1          number,                                           /* spare */
  spare2          number,                                           /* spare */
  endpoint_enc    raw(1000)                            /* encrypted endpoint */
  )
segment creation immediate
cluster c_obj#_intcol#(obj#, intcol#)
/
create index i_h_obj#_col# on histgrm$(obj#, col#)
  storage (maxextents unlimited)
/

Rem Base column statistics
create table hist_head$                            /* histogram header table */
 (obj#            number not null,                          /* object number */
  col#            number not null,                          /* column number */
  bucket_cnt      number not null,                      /* number of buckets */
  row_cnt         number not null,             /* number of rows in histgrm$ */
  cache_cnt       number,                     /* number of rows in row cache */
  null_cnt        number,                  /* number of nulls in this column */
  timestamp#      date,                   /* date of histogram's last update */
  sample_size     number,             /* for estimated stats, size of sample */
  minimum         number,           /* minimum value (if 1-bucket histogram) */
  maximum         number,           /* minimum value (if 1-bucket histogram) */
  distcnt         number,                            /* # of distinct values */
  lowval          raw(1000),
                        /* lowest value of column (second lowest if default) */
  hival           raw(1000),
                      /* highest value of column (second highest if default) */
  density         number,                                   /* density value */
  intcol#         number not null,                 /* internal column number */
  spare1          number,                /* sample number of distinct values */
  spare2          number,                                           /* flags */
                    /* 0x01 = user-specified stats                           */
                    /* 0x02 = global stats                                   */
                    /* 0x04 = endpoint actual values in histogram            */
  avgcln          number,                           /* average column length */
  spare3          number,                                           /* spare */
  spare4          number,                                           /* spare */
  minimum_enc     raw(1000),                      /* encrypted minimum value */
  maximum_enc     raw(1000)                       /* encrypted maximum value */
  )
  segment creation immediate
  storage (initial 350k next 100k maxextents unlimited pctincrease 0)
/
create index i_hh_obj#_col# on hist_head$(obj#, col#)
  storage (maxextents unlimited)
/
create index i_hh_obj#_intcol# on hist_head$(obj#, intcol#)
  storage (maxextents unlimited)
/

Rem fixed object (X$...) information
create table fixed_obj$            
( obj#          number not null,                            /* object number */
  timestamp     date not null,             /* object specification timestamp */
  flags         number,                    /* 0x00000001 = analyzed
                                              0x00000002 = locked            */
  spare1        number,
  spare2        number,
  spare3        number,
  spare4        varchar2(1000),
  spare5        varchar2(1000),
  spare6        date          
)
  segment creation immediate
  storage (maxextents unlimited)
/
create unique index i_fixed_obj$_obj# on fixed_obj$(obj#)
  storage (maxextents unlimited)
/

Rem Table to store optimizer statistics for table and table partition objects
create table tab_stats$
( obj#                number not null,                      /* object number */
  cachedblk           number,                      /* blocks in buffer cache */
  cachehit            number,                             /* cache hit ratio */
  logicalread         number,                     /* number of logical reads */
  rowcnt              number,                              /* number of rows */
  blkcnt              number,                            /* number of blocks */
  empcnt              number,                      /* number of empty blocks */
  avgspc              number, /* average available free space/iot ovfl stats */
  chncnt              number,                      /* number of chained rows */
  avgrln              number,                          /* average row length */
  avgspc_flb          number, /* avg avail free space of blocks on free list */
  flbcnt              number,                       /* free list block count */
  analyzetime         date,                  /* timestamp when last analyzed */
  samplesize          number,           /* number of rows sampled by Analyze */
  flags               number,           /* 0x00000001 = user-specified stats */
  im_imcu_count       number,         /* number of IMCUs for inmemory object */
  im_block_count      number,     /* number of IM blocks for inmemory object */
  im_sys_incarnation  number,   /* sys incarnation number at IM stats update */
  im_stat_update_time timestamp,     /* time when IM stats were last updated */
  scanrate            number,                           /* scan rate in MB/S */
  spare1              number,
  spare2              number,
  spare3              number,
  spare4              varchar2(1000),
  spare5              varchar2(1000),
  spare6              timestamp with time zone
)
  segment creation immediate
  storage (initial 32k next 100k maxextents unlimited pctincrease 0)
/
create unique index i_tab_stats$_obj# on tab_stats$(obj#)
  storage (maxextents unlimited)
/

Rem Table to store optimizer statistics for index and index partition objects
create table ind_stats$   
( obj#          number not null,                            /* object number */
  cachedblk     number,                            /* blocks in buffer cache */
  cachehit      number,                                   /* cache hit ratio */
  logicalread   number,                           /* number of logical reads */
  rowcnt        number,                       /* number of rows in the index */
  blevel        number,                                       /* btree level */
  leafcnt       number,                                  /* # of leaf blocks */
  distkey       number,                                   /* # distinct keys */
  lblkkey       number,                          /* avg # of leaf blocks/key */
  dblkkey       number,                          /* avg # of data blocks/key */
  clufac        number,                                 /* clustering factor */
  analyzetime   date,                        /* timestamp when last analyzed */
  samplesize    number,                 /* number of rows sampled by Analyze */
  flags         number,
  spare1        number,
  spare2        number,
  spare3        number,
  spare4        varchar2(1000),
  spare5        varchar2(1000),
  spare6        date
)
  segment creation immediate
  storage (initial 32k next 100k maxextents unlimited pctincrease 0)
/
create unique index i_ind_stats$_obj# on ind_stats$(obj#)
  storage (maxextents unlimited)
/

Rem ===========================================================================
Rem Object usage table - displays object usage information. For now, it has
Rem only index usage.
Rem ===========================================================================
create table object_usage                         /* object usage statistics */
( obj#               number not null,   /* object number of monitored object */
  flags              number not null,                       /* various flags */
                           /* index accessed during monitoring period : 0x01 */
  start_monitoring   char(19),                      /* start monitoring time */
  end_monitoring     char(19)                         /* end monitoring time */
)
  segment creation immediate
  initrans 30  pctused 50           /* itls and space so each row has an itl */
  storage (maxextents unlimited)
/
create index i_stats_obj# on object_usage(obj#)
  storage (maxextents unlimited)
/

Rem
Rem partobj$ table
Rem This table has a row per partitioned object
Rem obj# is the key
Rem There is a unique index on obj#
Rem NOTE: Please contact owner of dpart.bsq before changing this table.
Rem
create table partobj$ (
  obj#        number not null,/* object number of partitioned table or index */
  parttype    number not null,                          /* partitioning type */
             /* 1 = range, 2 = hash, 3 = system 4 = List, 5 = Ref;           */
             /* If range/list/hash, subparttype may be non-zero to indicate  */
             /* type of composite partitioning method.                       */
             /* see subparttype(spare1) for form of subpartitioning used.    */
  partcnt     number not null,                       /* number of partitions */
  partkeycols number not null,      /* number of columns in partitioning key */
  flags       number,           /* 0x0001 = local index                      */
                                /* 0x0002 = prefixed index                   */
                                /* 0x0004 = no-align index                   */
                                /* 0x0008 = domain index                     */
                                /* 0x0010 = compressed index                 */
                                /* 0x0020 = table has ref ptn'ed children    */
                                /* 0x0040 = table is interval partitioned    */
                                /* 0x0080 = System managed domain index      */
                                /* 0x0100 = IOT Top index                    */ 
                                /* 0x0200 = LOB column index                 */
                                /* 0x0400 = Tracked Table IOT Top index      */
                                /* 0x0800 = Segment creation deferred        */
                                /* 0x1000 = Segment creation immediate       */
                                /* 0x2000 = indexing off                     */
                                /* 0x8000 = table is interval subpartitioned */
                               /* 0x10000 = partition read only              */
                               /* 0x20000 = table is external                */
                               /* 0x40000 = table uses json vc partitioning  */
  defts#      number,                           /* default tablespace number */
  defpctfree  number not null,                            /* default PCTFREE */
  defpctused  number not null,          /* default PCTUSED (N/A for indexes) */
  defpctthres number,               /* default PCTTHRESHOLD (N/A for tables) */
  definitrans number not null,                           /* default INITRANS */
  defmaxtrans number not null,                           /* default MAXTRANS */
  deftiniexts number,                         /* default INITIAL extent size */
  defextsize  number,                            /* default NEXT extent size */
  defminexts  number,                                  /* default MINEXTENTS */
  defmaxexts  number,                                  /* default MAXEXTENTS */
  defextpct   number,                                 /* default PCTINCREASE */
  deflists    number not null,                    /* default FREELISTS value */
  defgroups   number not null,  /* default FREELIST GROUPS (N/A for indexes) */
  deflogging  number not null,   /* default logging attribute of the object: */
                              /* 0 - unspecified; 1 - LOGGING; 2 - NOLOGGING */
  spare1      number,                           /* default BUFFER_POOL value */

  /* 7 bytes of spare2 are currently spoken for */
  /* byte 0   : subparttype - non-zero implies Composite partitioning */
  /*            (1 - Range, 2 - Hash, 3 - System, 4 - List); */
  /* byte 1   : subpartkeycols; */
  /* bytes 2-3: defsubpartcnt */
  /* byte 4   : compression attribute of the partition */
  /*            following bit patterns are possible: */
  /*            00000000 : Compression not specified */
  /*            00000001 : Compression enabled for direct load operations */
  /*            00000010 : Compression disabled      */
  /*            00000101 : Compression enabled for all operations */
  /*            00001001 : Archive Compression: level 1 */
  /*            00010001 : Archive Compression: level 2 */
  /*            00011001 : Archive Compression: level 3 */
  /*            00100001 : Archive Compression: level 4 */
  /*            00101001 : Archive Compression: level 5 */
  /*            00110001 : Archive Compression: level 6 */
  /*            00111001 : Archive Compression: level 7 */
  /* byte 5   : inmemory columnar attributes            */
  /*            00000000 : imc not specified            */
  /*            00000001 : imc explicitly enabled       */
  /*            00000010 : imc explicitly not enabled   */
  /*            00000100 : imc_mirrormap */
  /*            00001000 : imc level 1 */
  /*            00010000 : imc_preload  */
  /*            00100000 : imc_mapby1  */
  /*            01000000 : imc_mapby2  */
  /*            10000000 : imc level 2          */
  /* byte 6:    00000001 : imc level 3    */            
  /*            00000010 : imc level 4*/
  /*            00000100 : duplicate1  */
  /*            00001000 : duplicate2  */
  /*            IMC preload priority levels */
  /*            00010000 : priority NONE */
  /*            00100000 : priority LOW */
  /*            01000000 : priority MEDIUM */
  /*            10000000 : priority HIGH */
  /* byte 7:    00000001 : priority CRITICAL */
  spare2      number,                       
  /* byte 0 of spare3 stores dtydef of partition interval
   * (either DTYNUM, DTYIYM, or DTYIDS)
   * byte 1 of spare3 stores dtydef of subpartition interval
   * (either DTYNUM, DTYIYM, or DTYIDS)
   * byte 3 of spare3 stores additional imc flags (for svc, order by)
   * byte 4 of spare3 stores additional compression flags
   */
  /* byte 2 of spare3 : cell columnar cache attributes      */
  /*            00000000 : cellcache not specified          */
  /*            00000001 : cellcache explicitly enabled     */
  /*            00000010 : cellcache explicitly not enabled */
  /*            00000100 : cellcache 12.1.0.2 compat        */
  /*            00001000 : cellcache comp for query         */
  /*            00010000 : cellcache comp for capacity      */
  spare3      number,                                       /* spare column  */
  definclcol  number,       /* default iot include column # (N/A for tables) */
  parameters  varchar2(1000),  /* default parameter string for domain index  */
  interval_str varchar2(1000),                   /* string of interval value */
  interval_bival raw(200),              /* binary representation of interval */
  defmaxsize  number,                                  /* default MAXSIZE    */
  subptn_interval_str varchar2(1000),     /* string of subptn interval value */
  subptn_interval_bival raw(200))  /* bin. representation of subptn interval */
  segment creation immediate
/
create unique index i_partobj$ on partobj$(obj#)
/

REM
REM END OF PSEUDO-BOOTSTRAP OBJECTS
REM ===============================
REM

REM Create table deferred_stg$ for deferred segment creation.
REM For objects with deferred segment creation, a row will be inserted
REM into deferred_stg$ instead of seg$. This row will contain storage
REM attributes which will be used during the first insert.
create table deferred_stg$                           /* shadow segment table */
( 
  obj#          number not null,                            /* object number */
  pctfree_stg   number,                                           /* PCTFREE */
  pctused_stg   number,                                           /* PCTUSED */
  size_stg      number,                                              /* SIZE */
  initial_stg   number,                                           /* INITIAL */
  next_stg      number,                                              /* NEXT */
  minext_stg    number,                                        /* MINEXTENTS */
  maxext_stg    number,                                        /* MAXEXTENTS */
  maxsiz_stg    number,                                           /* MAXSIZE */
  lobret_stg    number,                                      /* LOBRETENTION */
  mintim_stg    number,                                           /* MIN tim */
  pctinc_stg    number,                                       /* PCTINCREASE */
  initra_stg    number,                                          /* INITRANS */
  maxtra_stg    number,                                          /* MAXTRANS */
  optimal_stg   number,                                           /* OPTIMAL */
  maxins_stg    number,                                      /* MAXINSTANCES */
  frlins_stg    number,                                    /* LISTS/instance */
  flags_stg     number,                                             /* flags */
  bfp_stg       number,                                       /* BUFFER_POOL */
  enc_stg       number,                                        /* encryption */
  cmpflag_stg   number,                                  /* compression type */
  cmplvl_stg    number,                                 /* compression level */
  imcflag_stg   number,                     /* in-memory columnar (IMC) flag */
  ccflag_stg    number,                                   /* CELLCACHE flags */
  flags2_stg    number)                                  /* additional flags */
  segment creation immediate
/
CREATE UNIQUE INDEX i_deferred_stg1 ON deferred_stg$(obj#)
/

REM NOTE:
REM =====
REM DO NOT create any object before dependency$ except for Bootstrap,
REM Pseudo-bootstrap or objects with explicit "segment creation immediate"
REM clause to disable Deferred Segment Creation for them in the 
REM SEED Pluggable Database in a Consolidated Database.

create table dependency$                                 /* dependency table */
( d_obj#        number not null,                  /* dependent object number */
  d_timestamp   date not null,   /* dependent object specification timestamp */
  order#        number not null,                             /* order number */
  p_obj#        number not null,                     /* parent object number */
  p_timestamp   date not null,      /* parent object specification timestamp */
  d_owner#      number,                           /*  dependent owner number */
  property      number not null,                   /* 0x01 = HARD dependency */
                                                   /* 0x02 = REF  dependency */
                                          /* 0x04 = FINER GRAINED dependency */
  d_attrs       raw("M_CSIZ"), /* Finer grain attr. numbers if finer grained */
  d_reason      raw("M_CSIZ"))  /* Reason mask of attrs causing invalidation */
storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/
create table access$                                         /* access table */
( d_obj#        number not null,                  /* dependent object number */
  order#        number not null,                  /* dependency order number */
  columns       raw("M_BVCO"),                /* list of cols for this entry */
  types         number not null)                             /* access types */
  storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/
create unique index i_dependency1 on
  dependency$(d_obj#, d_timestamp, order#) 
  storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/
create index i_dependency2 on
  dependency$(p_obj#, p_timestamp)
  storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/
create index i_access1 on
  access$(d_obj#, order#) 
  storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/

create table userauth$                           /* user authorization table */
( user#          number not null,                             /* user number */
  grantor#      number not null,                      /* grantor user number */
  grantee#      number not null,                      /* grantee user number */
  privilege#    number not null,                    /* user privilege number */
  sequence#     number not null,                    /* unique grant sequence */
  parent        rowid,                                             /* parent */
  option$       number)                                 /* null = no options */
/
create unique index i_userauth1 on 
  userauth$(user#, grantor#, grantee#, privilege#)
/

create table ugroup$                         /* rollback segment group table */
( ugrp#         number not null,                        /* undo group number */
  name          varchar2("M_IDEN_30") not null,           /* undo group name */
  seq#          number,
  spare1        number,
  spare2        varchar2("M_IDEN"),
  spare3        number
)
/
create index i_ugroup1 on ugroup$(name)
/
create index i_ugroup2 on ugroup$(ugrp#)
/
create table tsq$                                  /* tablespace quota table */
( ts#           number not null,                        /* tablespace number */
  user#         number not null,                              /* user number */
  grantor#      number not null,                               /* grantor id */
  blocks        number not null,         /* number of blocks charged to user */
  maxblocks     number,     /* user's maximum number of blocks, NULL if none */
  priv1         number not null,            /* reserved for future privilege */
  priv2         number not null,            /* reserved for future privilege */
  priv3         number not null)            /* reserved for future privilege */
cluster c_user# (user#)
/
create table syn$                                           /* synonym table */
( obj#          number not null,                            /* object number */
  node          varchar2("M_XDBI"),                        /* node of object */
  owner         varchar2("M_IDEN"),                          /* object owner */
  name          varchar2("M_IDEN") not null)                  /* object name */
/
create table view$                                             /* view table */
( obj#          number not null,                            /* object number */
  audit$        varchar2("S_OPFL") not null,             /* auditing options */
  cols          number not null,                        /* number of columns */
  intcols       number not null,               /* number of internal columns */
  property      number not null,             /* view properties (bit flags): */
                /* 0x0001 =       1 = this is typed view                     */
                /* 0x0002 =       2 = view has ADT column(s)                 */
                /* 0x0004 =       4 = view has nested table column(s)        */
                /* 0x0008 =       8 = view has REF column(s)                 */
                /* 0x0010 =      16 = view has array column(s)               */
                /* 0x0020 =      32 = Editioning View                        */
                /* 0x1000 =    4096 = view has primary key-based oid         */
                /* 0x4000 =   16384 = view is read-only                      */
               /* 0x10000 =   65536 = OID is sytem generated                 */
               /* 0x20000 =         = view is used by AQ                     */
            /* 0x08000000 =         = view is a sub view                     */
            /* 0x10000000 =         = view is packed object view             */
  flags         number not null,                  /* view flags (bit flags): */
                /* 0x0800 =    2048 = view/table has security policy         */
                /* 0x1000 =    4096 = view is insertable via trigger         */
                /* 0x2000 =    8192 = view is updatable via trigger          */
                /* 0x4000 =   16384 = view is deletable via trigger          */
             /* 0x0080000 =  524288 = view is referenced by MV (Summary)     */
             /* 0x0100000 = 1048576 = view is referenced by query rewrite MV */
             /* 0x0400000 = 4194304 = view has sub views defined under it    */
  textlength    number,                               /* length of view text */
  text          long)                                           /* view text */
  storage (initial 10k next 100k maxextents unlimited pctincrease 0)
/
create table typed_view$                   /* additional info for typed view */
( obj#            number not null,                          /* object number */
  typeowner       varchar2("M_IDEN"),                   /* owner of row type */
  typename        varchar2("M_IDEN"),                    /* name of row type */
  typetextlength  number,                         /* length of row type text */
  typetext        varchar2("M_VCSZ"),                           /* type text */
  oidtextlength   number,                              /* length of oid text */
  oidtext         varchar2("M_VCSZ"),                            /* oid text */
  transtextlength number,                 /* length of transformed view text */
  transtext       long,                             /* transformed view text */
  undertextlength number,       /* length of under clause text for sub-views */
  undertext       varchar2("M_VCSZ"))     /* under clause text for sub-views */
/
create table superobj$        /* stores info about table/view hierarchies */
( subobj#         number not null,            /* object number of sub object */
  superobj#       number not null)          /* object number of super object */
/
create unique index i_superobj1 on superobj$(subobj#)
/
create index i_superobj2 on superobj$(superobj#)
/
create table seq$
( obj#          number not null,                            /* object number */
  increment$    number not null,            /* the sequence number increment */
  minvalue      number,                         /* minimum value of sequence */
  maxvalue      number,                         /* maximum value of sequence */
  cycle#        number not null,                      /* 0 = FALSE, 1 = TRUE */
  order$        number not null,                      /* 0 = FALSE, 1 = TRUE */
  cache         number not null,                 /* how many to cache in sga */
  highwater     number not null,                     /* disk high water mark */
  audit$        varchar2("S_OPFL") not null,             /* auditing options */
  flags         number,                              /* 0x08 LOGICAL STANDBY */
  partcount     number,                          /* Sequence Partition Count */
  supplemental log group seq$_log_grp (obj#) always
)
/
create unique index i_view1 on view$(obj#)
/
create unique index i_typed_view1 on typed_view$(obj#)
/
create unique index i_syn1 on syn$(obj#)
/
create index i_syn2 on syn$(owner,name)
/
create unique index i_seq1 on seq$(obj#)
/
create table idnseq$     /* stores table identity column to sequence mapping */
( obj#         number not null,                       /* table object number */
  intcol#      number not null,                    /* identity column number */
  seqobj#      number not null,                    /* sequence object number */
  startwith    number not null,                   /* sequence starting value */
  supplemental log group idnseq$_log_grp (obj#, intcol#, seqobj#) always
)
/
create unique index i_idnseq1 on idnseq$(obj#, intcol#)
/
create index i_idnseq2 on idnseq$(seqobj#)
/
rem NOTE 
rem Logminer/Streams uses contents of this table. 
rem Please do not reuse any flags without verifying the impact of your 
rem changes on inter-op.  
rem moved into core to remove dependencies on future files
create table lob$                                   /* LOB information table */
( obj#          number not null,          /* object number of the base table */
  col#          number not null,                            /* column number */
  intcol#       number not null,                   /* internal column number */
  lobj#         number not null,                /* object number for the LOB */
  part#         number not null,                  /* this column is not used */
  ind#          number not null,                  /* LOB index object number */
  ts#           number not null,         /* segment header tablespace number */
  file#         number not null,               /* segment header file number */
  block#        number not null,              /* segment header block number */
  chunk         number not null,           /* oracle blocks in one lob chunk */
  pctversion$   number not null,                             /* version pool */
  flags         number not null,                           /* 0x0000 = CACHE */
                                                 /* 0x0001 = NOCACHE LOGGING */
                                               /* 0x0002 = NOCACHE NOLOGGING */
                                             /* 0x0008 = CACHE READS LOGGING */
                                           /* 0x0010 = CACHE READS NOLOGGING */
                                          /* 0x0020 = retention is specified */
                                       /* 0x0040 = Index key holds timestamp */
                                      /* 0x0080 = need to drop the freelists */
                                                 /* 0x0100 = CACHE NOLOGGING */
                                                   /* 0x0200 = CACHE LOGGING */
                                                            /* 0x0400 = SYNC */
                                                           /* 0x0800 = ASYNC */
                                                      /* 0x1000 = Encryption */
                                               /* 0x2000 = Compression - Low */
                                            /* 0x4000 = Compression - Medium */
                                              /* 0x8000 = Compression - High */
                                             /* 0x10000 = Sharing: LOB level */
                                          /* 0x20000 = Sharing: Object level */
                                              /* 0x40000 = Sharing: Validate */
  property      number not null,           /* 0x00 = user defined lob column */
                                    /* 0x01 = kernel column(s) stored as lob */
                                     /* 0x02 = user lob column with row data */
                                            /* 0x04 = partitioned LOB column */
                                   /* 0x0008 = LOB In Global Temporary Table */
                                          /* 0x0010 = Session-specific table */
                                      /* 0x0020 = lob with compressed header */ 
                                        /* 0x0040 = lob using shared segment */
                                  /* 0x0080 = first lob using shared segment */
                                   /* 0x0100 = klob and inline image coexist */
                                /* 0x0200 = LOB data in little endian format */
                                                   /* 0x0800 = 11g LOCAL lob */
                                        /* 0x1000 = Delayed Segment Creation */
                                                  /*0x2000 = 32K inline lobs */
  retention     number not null,         /* retention value = UNDO_RETENTION */
  freepools     number not null,      /* number of freepools for LOB segment */
  spare1        number,
  spare2        number,
  spare3        varchar2(255)
)
cluster c_obj#(obj#)
/
create index i_lob1 on lob$(obj#, intcol#)
/
create unique index i_lob2 on lob$(lobj#)
/
rem NOTE 
rem Logminer/Streams uses contents of this table. 
rem Please do not reuse any flags without verifying the impact of your 
rem changes on inter-op.  
create table coltype$                        /* additional column info table */
( obj#          number not null,             /* object number of base object */
  col#          number not null,                            /* column number */
  intcol#       number not null,                   /* internal column number */
  toid          raw(16) not null,                   /* column's ADT type OID */
  version#      number not null,             /* internal type version number */
  packed        number not null,                 /* 0 = unpacked, 1 = packed */
  intcols       number,                        /* number of internal columns */
                                          /* storing the exploded ADT column */
  intcol#s      raw("M_CSIZ"),        /* list of intcol#s of columns storing */
                          /* the unpacked ADT column; stored in packed form; */
                                          /* each intcol# is stored as a ub2 */
  flags         number,
                     /* flags to indicate whether column type is ADT, Array, */
                                                      /* REF or Nested table */
                           /* 0x02 - adt column                              */
                           /* 0x04 - nested table column                     */
                           /* 0x08 - varray column                           */
                           /* 0x10 - ref column                              */
                           /* 0x20 - retrieve collection out-of-line         */
                           /* 0x20 - don't strip the null image              */
                           /* 0x40 - don't chop null image                   */
                           /* 0x40 - collection storage specified            */
                           /* 0x80 - column stores an old (8.0) format image */
                          /* 0x100 - data for this column not yet upgraded   */
                          /* 0x200 - ADT column is substitutable             */
                          /* 0x400 - NOT SUBSTITUTABLE specified explicitly  */
                          /* 0x800 - SUBSTITUTABLE specified explicitly      */
                         /* 0x1000 - implicitly not substitutable            */
                         /* 0x2000 - The typeid column stores the toid       */
                         /* 0x4000 - The column is an opaque type column     */ 
                         /* 0x8000 - nested table name is system generated   */
  typidcol#     number,           /* intcol# of the type discriminant column */
  synobj#       number)              /* obj# of type synonym of the col type */
cluster c_obj#(obj#)
/
create index i_coltype1 on coltype$(obj#, col#)
/
create unique index i_coltype2 on coltype$(obj#, intcol#)
/
create table subcoltype$
( obj#          number not null,             /* object number of base object */
  intcol#       number not null,                   /* internal column number */
  toid          raw(16) not null,                   /* column's ADT type OID */
  version#      number not null,             /* internal type version number */
        
  intcols       number,                        /* number of internal columns */
                                          /* storing the exploded ADT column */
  intcol#s      raw("M_CSIZ"),        /* list of intcol#s of columns storing */
                          /* the unpacked ADT column; stored in packed form; */
                                          /* each intcol# is stored as a ub2 */
  flags         number,
                          /* 0x01 - This type was stated in the IS OF clause */
                          /* 0x02 - This type has ONLY in the IS OF clause   */
  synobj#       number)  /* obj# of synonym specified for substitutable type */
cluster c_obj#(obj#)
/
create index i_subcoltype1 on subcoltype$(obj#, intcol#)
/
create table ntab$                         /* nested table information table */
( obj#          number not null,             /* object number of base object */
  col#          number not null,                            /* column number */
  intcol#       number not null,                   /* internal column number */
  ntab#         number not null,     /* object number of nested table object */
  name          varchar2("M_VCSZ") default 'NT$' not null 
                                    /* qualified name of the nested table col*/
)
cluster c_obj#(obj#)
/
create index i_ntab1 on ntab$(obj#, col#)
/
create unique index i_ntab2 on ntab$(obj#, intcol#)
/
create index i_ntab3 on ntab$(ntab#)
/
create table refcon$                                /* REF CONstraints table */
( obj#          number not null,             /* object number of base object */
  col#          number not null,                            /* column number */
  intcol#       number not null,                   /* internal column number */
  reftyp        number not null,                            /* REF type flag */
                                                     /* 0x01 = REF is scoped */
                                             /* 0x02 = REF stored with rowid */
                                             /* 0x04 = Primary key based ref */
           /* 0x08 = Primary key based ref allowed in an unscoped ref column */
  stabid        raw(16),                   /* OID of scope table (if scoped) */
  expctoid      raw(16) /* TOID of exploded columns when ref is user-defined */
)
cluster c_obj#(obj#)
/
create index i_refcon1 on refcon$(obj#, col#)
/
create unique index i_refcon2 on refcon$(obj#, intcol#)
/

rem Logminer/Streams uses contents of this table. 
rem Please do not reuse any flags without verifying the impact of your 
rem changes on inter-op.  
/* The opqtype$ stores extra information for the xmltype */
create table opqtype$                         /* extra info for opaque types */
(
  obj#        number not null,                /* object number of base table */
  intcol#     number not null,                     /* internal column number */
  type        number,                              /* The opaque type - type */
                                                       /* 0x01 - XMLType */
  flags       number,                          /* flags for the opaque type */
                              /* -------------- XMLType flags ---------
                               * 0x0001 (1) -- XMLType stored as object
                               * 0x0002 (2) -- XMLType schema is specified
                               * 0x0004 (4) -- XMLType stored as lob 
                               * 0x0008 (8) -- XMLType stores extra column
                               * 
                               * 0x0020 (32)-- XMLType table is out-of-line 
                               * 0x0040 (64)-- XMLType stored as binary
                               * 0x0080 (128)- XMLType binary ANYSCHEMA
                               * 0x0100 (256)- XMLType binary NO non-schema
                               * 0x0200 (512)- Table is hierarchy enabled
                               * 0x0400 (1024)- XMLType table
                               * 0x0800 (2048)- Varray stored as LOB
                               * 0x1000 (4096)- Varray stored as Table
                               * 0x2000 (8192)- Doc fidelity
                               * 0x4000 (16384)- Has XML tree index
                               */
  /* Flags for XMLType (type == 0x01). Override them when necessary  */
  lobcol      number,                                          /* lob column */
  objcol      number,                                      /* obj rel column */
  extracol    number,                                      /* extra info col */
  schemaoid   raw(16),                                     /* schema oid col */
  elemnum     number,                                      /* element number */
  schemaurl   varchar2(4000)                       /* The name of the schema */
)
cluster c_obj#(obj#)
/
create unique index i_opqtype1 on opqtype$(obj#, intcol#)
/

create sequence ugroup_sequence   /* sequence for undo group    cache (lab$) */
  increment by 1
  start with 1
  minvalue 0
  nomaxvalue
  cache 10
  order
  nocycle
/
create table props$
( name          varchar2("M_IDEN") not null,                /* property name */
  value$        varchar2("M_VCSZ"),                        /* property value */
  comment$      varchar2("M_VCSZ"))               /* description of property */
/
insert into props$ 
values('DICT.BASE', '2', 'dictionary base tables version #')
/
insert into props$
values('DEFAULT_TEMP_TABLESPACE', 'SYSTEM',
       'Name of default temporary tablespace')
/
insert into props$
values('DEFAULT_PERMANENT_TABLESPACE', 'SYSTEM',
       'Name of default permanent tablespace')
/
rem Application Edition
create table edition$
(
  obj#      number not null,                                 /* edition obj# */
  p_obj#    number,                                   /* parent edition obj# */
  flags     number,
  code      blob,
  audit$    varchar2("S_OPFL") not null,                 /* auditing options */
  spare1    number,
  spare2    varchar2("M_IDEN")
)
/
create global temporary table editioning_types$ (type# number not null)
on commit delete rows
/
create table user_editioning$
(
  user# number not null,
  type# number not null
)
/
create index i_user_editioning on user_editioning$(user#)
/
create edition ora$base
/
insert into props$
values('DEFAULT_EDITION', 'ORA$BASE',
       'Name of the database default edition')
/
create table migrate$
( version#   varchar2("M_IDEN"),                    /* version migrated from */
  migdate    date,              /* date the migration from v7->v8 took place */
  migrated   number not null     /* 0=not migrated, 1=migrated from v7 to v8 */
)
/
insert into migrate$ values (NULL, NULL, 0)
/

REM
REM viewcon$ stores the view constraint text: one row per constraint and 
REM   the text is stored for the revalidation of view constraints in future
REM   release (stored but never used in 8.2). 
REM
create table viewcon$                            /* constraint text for view */
( obj#            number not null,                     /* view object number */
  con#            number,                               /* constraint number */
  conname         varchar2("M_IDEN"),                     /* constraint name */
  type#           number,                                 /* constraint type */
                              /* 2 = primary key, 3 = unique, 4= referential */
  con_text        clob,                                   /* constraint text */
  robj#           number,                        /* referenced object number */
  property        number                         /* view constraint property */
                                                   /* 0x00040000 set RELY on */
                                                 /* 0x00080000 /* Reset RELY */
)
/
create index i_viewcon1 on viewcon$(obj#)
/
create index i_viewcon2 on viewcon$(robj#)
/
/* if icoldep$ is empty for an index, the index depends on the cols in icol$ */
create table icoldep$                   /* which columns an index depends on */
( obj#          number not null,                                 /* index id */
  bo#           number not null,                                 /* table id */
  intcol#       number not null    /* intcol# in table that index depends on */
)
cluster c_obj#(bo#)
/
create index i_icoldep$_obj on icoldep$ (obj#)
/
create table dual                   /* pl/sql's standard pckg requires dual. */
  (dummy varchar2(1))    /* note, the optimizer knows sys.dual is single row */
  storage (initial 1)
/
insert into dual values('X')
/
create public synonym dual for dual
/
create table sysauth$                          /* system authorization table */
( grantee#      number not null,          /* grantee number (user# or role#) */
  privilege#    number not null,                      /* role or privilege # */
  sequence#     number not null,                    /* unique grant sequence */
  option$       number)                                       /* null = none */
                                                      /* 0x01 = admin option */
                          /* 0x04 = tuple represents ONLY a Common Privilege */
                                                  /* 0x08 = Common Privilege */
                                /* 0x10 = Common Privilege with admin option */
/
create table objpriv$                       /* privileges granted to objects */
( obj#          number not null,                            /* object number */
  privilege#    number not null)                         /* privilege number */
/
create table defrole$                                  /* default role table */
( user#         number not null,                                  /* user id */
  role#         number not null)                          /* default role id */
/
create unique index i_sysauth1 on sysauth$(grantee#, privilege#)
/
create unique index i_defrole1 on defrole$(user#, role#)
/

Rem This table will be used to replicate in the Root descriptions of 
Rem local administrative privileges (e.g. SYSDBA) granted in PDBs of a CDB.  
Rem
Rem Replicatintg this information in the Root will make it possible to 
Rem determine whether a user may perform an operation which depends on an 
Rem administrative privilege granted in a Container which is closed.
Rem
Rem NOTES: 
Rem   - Instead of grantee's id we will store grantee's name because
Rem     user#'s in a PDB are not readily accessible from another Container, 
Rem     especially if a PDB is closed
Rem   - we will not store an indicator of whether a privilege was granted
Rem     with Admin Option because we will not use this table to determine 
Rem     whether a user may grant a given privilege
Rem Proj 46885: add new columns to enforce security on PDB local admin users.
Rem Proj 47234: add a new column to track federationally granted privileges
create table cdb_local_adminauth$
( con_uid       number not null,                          /* Container's UID */
  grantee$      varchar2("M_IDEN") not null,                 /* grantee name */
  privileges    number default 0 not null,  /* privileges granted to grantee */
  passwd        varchar2(4000) not null,   /* List of "password hash" values */
  flags         number default 0 not null, /* bits defined over flags column: */
                                          /* 0x01 - grantee is a Common User */
                                 /* 0x02 - entry out-of-sync with dictionary */
                             /* 0x04 - user associated with a Common Profile */
                                    /* 0x08 - grantee is a Federational User */
                       /* 0x10 - user associated with a Federational Profile */
                        /* 0x20 - profile limits out-of-sync with dictionary */
                                          /* 0x40 - grantee is External user */
  spare1        number,
  spare2        varchar2("M_IDEN"),
  lcount        number default 0,          /* count of failed login attempts */
  astatus       number default 0,                   /* status of the account */
                /* 0x00 =       0 = Open                                     */
                /* 0x01 =       1 = Expired                                  */
                /* 0x02 =       2 = Expired(GRACE)                           */
                /* 0x04 =       4 = Locked(TIMED)                            */
                /* 0x05 =       5 = Expired & Locked(TIMED)                  */
                /* 0x06 =       6 = Expired(GRACE) & Locked(TIMED)           */
                /* 0x08 =       8 = Locked                                   */
                /* 0x09 =       9 = Expired & Locked                         */
                /* 0x0A =      10 = Expired(GRACE) & Locked                  */
                /* 0x10 =      16 = Password matches a default value         */
  exptime       date,                     /* actual password expiration time */
  ltime         date,                         /* time when account is locked */
  lsltime       date,                          /* Last Successful Logon Time */
  passwd_profile varchar2("M_IDEN"),                /* password profile name */
  passwd_limit   varchar2(4000),                /* profile's password limits */
                             /* privileges granted federationally to grantee */
  fed_privileges number default 0 not null,
  ext_username   varchar2(4000))                        /* external username */
/

create unique index i_cdb_local_adminauth_1 
  on cdb_local_adminauth$(con_uid, grantee$)
/

REM This table is an extension to col$ and is used (for now) to store the 
REM default value with which a column was added
create table ecol$
(
  tabobj#      number,
  colnum       number, 
  binaryDefVal blob,
  guard_id     number)
tablespace system
/

REM index on ecol$
create index ecol_ix1 on ecol$(tabobj#, colnum);

REM Additional info pertaining to Editioning Views (EVs):
REM   mapping between EVs and their underlying base tables.
CREATE TABLE ev$ 
(
  ev_obj# NUMBER NOT NULL, /* id of an EV */
      /* id of the schema to which EV's base table belongs */
  base_tbl_owner# NUMBER NOT NULL, 
  base_tbl_name VARCHAR2("M_IDEN") NOT NULL, /* EV's base table name */
                     /* id of an Edition in which this EV was defined */
  edition_obj# NUMBER NOT NULL)
tablespace system
/

CREATE UNIQUE INDEX i_ev1 ON ev$(ev_obj#)
/

CREATE UNIQUE INDEX i_ev2 
    ON ev$(base_tbl_owner#, base_tbl_name, edition_obj#)
/

REM Additional info for EV columns:
REM mapping between EV columns and their corresponding base table columns
CREATE TABLE evcol$ 
(
  ev_obj# NUMBER NOT NULL, /* id of an EV */
  ev_col_id NUMBER NOT NULL, /* column id of an EV column */
  /* name of a corresponding base table column */
  base_tbl_col_name VARCHAR2("M_IDEN") NOT NULL)
tablespace system
/

CREATE UNIQUE INDEX i_evcol1 ON evcol$(ev_obj#, ev_col_id)
/

REM create a table to store the sql errors that occur during parsing so that
REM the next time the same bad sql is issued we can look up from this table
REM and throw the same error instead of doing a hard parse

create table sqlerror$
(
  sqlhash   varchar(32)  not null,                    /* sql stmt hash value */
  error#    number       not null,                                  /* error */
  errpos#    number      not null,                         /* error position */
  flags     number       not null,                    /* Flags - 0 - InValid */
                                                              /* 1 - InValid */
  spare1    number default 0 not null,                              /* spare */
  spare2    number default 0 not null,                              /* spare */
  spare3    number default 0 not null)                              /* spare */
/

REM Create a table container$ for containers (Root and Pluggable Databases) 
REM to store container-related attributes (for feature Pluggable Databases)
create table container$
(
 obj#            number not null,         /* Object number for the container */
 con_id#         number not null,                            /* container ID */
 dbid            number not null,                             /* database ID */
 con_uid         number not null,                               /* unique ID */
 status          number not null,                       /* active, plugged...*/
 create_scnwrp   number not null,                       /* creation scn wrap */
 create_scnbas   number not null,                       /* creation scn base */
 clnscnwrp       number,    /* clean offline scn - zero if not offline clean */
 clnscnbas       number,       /* clnscnbas - scn base, clnscnwrp - scn wrap */
 rdba            number not null,                 /*  r-dba of the container */
 flags           number,                                            /* flags */
 vsn             number,                                     /* software vsn */
 fed_root_con_id# number,         /* CON_ID of Federation Root if applicable */
 spare3          varchar2("M_IDEN"),                                /* spare */
 spare4          varchar2("M_IDEN"),                                /* spare */
 spare5          number,                                            /* spare */
 spare6          number,                                            /* spare */
 undoscn         number,                         /* undo mode switchover scn */
 srcpdb          varchar2("M_IDEN"),                      /* source PDB name */
 linkname        varchar2("M_XDBI"),                            /* link name */
 upgrade_priority number,                                /* upgrade priority */
 rafn#           number,                                    /* reserved afn# */
 containers_port number,                                /* containers() port */
 containers_host varchar2("M_XDBI"),                    /* containers() host */
 remote_port     number,                                      /* remote port */
 remote_host     varchar2("M_XDBI"),                          /* remote host */
 remote_srvc     varchar2("M_XDBI"),                       /* remote service */
 srcpdbuid       number,                                   /* source PDB uid */
 lastrcvscn      number,                                /* last recovery scn */
 remote_user     varchar2("M_IDEN"),                          /* remote user */
 f_cdb_dbid      number,                         /* root dbid of foreign cdb */
 uscn            number,                                        /* unplugscn */
 f_con_id#       number,                             /* foreign container ID */
 undots          date,                         /* undo mode change timestamp */
 refreshint      number,                             /* pdb refresh interval */
 postplugscn     number,                          /* postplug completion scn */
 postplugtime    date,                      /* postplug completion timestamp */
 tenant_id       varchar2(255),                                /* tenant key */
 snapint         number                             /* pdb snapshot interval */
)
/

CREATE UNIQUE INDEX i_container1 ON container$(obj#)
/

CREATE UNIQUE INDEX i_container2 ON container$(con_id#)
/

CREATE UNIQUE INDEX i_container3 ON container$(con_uid)
/

create table cdb_file$                    /* file table in a consolidated db */
(
 file#         number not null,                    /* file identifier number */
 con_id#       number not null,                              /* container ID */
 mtime         date,                        /* time it was created, modified */
 spare1        number,                                              /* spare */
 spare2        number,                                              /* spare */
 spare3        number,                                              /* spare */
 spare4        number,                                              /* spare */
 f_afn         number not null,              /* foreign absolute file number */
 f_dbid        number not null,                       /* foreign database id */
 f_cpswrp      number not null,                    /* foreign checkpoint scn */
 f_cpsbas      number not null,
 f_prlswrp     number not null,              /* foreign plugin resetlogs scn */
 f_prlsbas     number not null,
 f_prlstim     number not null,             /* foreign plugin resetlogs time */
 ts#           number,                                  /* tablespace number */
 relfile#      number,                               /* relative file number */
 cscnwrp       number,                                     /* createscn wrap */
 cscnbas       number,                                     /* createscn base */
 spare5        varchar2(1000),                                      /* spare */
 spare6        date,                                                /* spare */
 src_afn       number,                                         /* source afn */
 tgt_afn       number,                                         /* target afn */
 status        number,                                        /* file status */
 flags         number,                                              /* flags */
 blks          number,                             /* number of blks in file */
 spare7        number,
 spare8        number,
 spare9        number,
 spare10       number,
 spare11       varchar2("M_IDEN"),
 spare12       varchar2("M_IDEN")
)
/

CREATE UNIQUE INDEX i_cdbfile1 ON cdb_file$(file#, con_id#)
/

REM Pluggable history tracking table. tracks creation, unplug, plug operations
REM to provide PDB lineage information.
 
create table pdb_history$
(
 name       varchar2("M_IDEN") not null,                  /* Name of the PDB */
 con_id#    number  not null,                                /* Container ID */
 dbid       number  not null,                                 /* DBID of PDB */
 guid       raw(16) not null,                                 /* GUID of PDB */
 scnbas     number  not null,             /* SCN base when operation occured */
 scnwrp     number  not null,             /* SCN wrap when operation occured */
 time       date    not null,                 /* time when operation occured */
 operation  varchar2(16)  not null,   /* CREATE, CLONE, UNPLUG, PLUG, RENAME */
 db_version number  not null,                            /* Database version */
 c_pdb_name varchar2("M_IDEN"),             /* Created, Cloned from PDB name */
 c_pdb_dbid number,                         /* Created, Cloned from PDB DBID */
 c_pdb_guid raw(16),                        /* Created, Cloned from PDB GUID */
 c_db_name  varchar2("M_IDEN_128"),            /* Created, Cloned in DB name */
 c_db_uname varchar2("M_IDEN"),         /* Created, Cloned in DB unique name */
 c_db_dbid  number,                               /* Created, Cloned in DBID */
 clonetag   varchar2(128),                                 /* Clone tag name */
 spare1     number,                                                 /* spare */
 spare2     number,                                                 /* spare */
 spare3     varchar2("M_IDEN"),                                     /* spare */
 spare4     varchar2("M_IDEN")                                      /* spare */
)
/

REM Table containing values of CONTAINER_DATA Attributes (both default and 
REM object-specific)
create table condata$
(
  user#  number not null,
  obj#   number not null, /* 0 represents a default CONTAINER_DATA attribute */
  con#   number not null                    /* 0 represents ALL (containers) */
)
/

CREATE UNIQUE INDEX i_condata1 ON condata$(user#, obj#, con#)
/

CREATE INDEX i_condata2 ON condata$(obj#)
/

CREATE INDEX i_condata3 ON condata$(con#)
/

create table adminauth$
(
  user#        number not null,                                   /* user id */
  syspriv      number not null,           /* Local administrative privileges */
  common       number not null,         /* Commonly granted admin privileges */
  fedpriv      number default 0 not null     /* Federationally granted privs */
)
/

CREATE UNIQUE INDEX i_adminauth1 ON adminauth$(user#)
/

Rem This table will be populated by DBMS_PDB.CHECK_PLUG_COMPATIBILITY() if 
Rem that function determines that a database or a pluggable database described
Rem by a specified XML file may not be plugged into the CDB.
Rem
Rem DBMS_PDB.CHECK_PLUG_COMPATIBILITY() may report multiple reasons which plug
Rem in operation will not succeed (cause# will identify individual reasons 
Rem while line# will be used if an explanation of a reason must span multiple 
Rem records
create table pdb_alert$
(
  cause#      number not null,                  /* cause number of the alert */
  type#       number not null,
  time        timestamp not null,                        /* Time it happened */
  line#       number not null,
  /* reason why a plug in operation may not be performed */
  msg$        varchar2(4000) not null,
  /* name of a non-CDB or a PDB described by the specified XML file */
  name        varchar2("M_IDEN") not null,
  /* if the specified XML file describes a PDB, UID of that PDB */
  con_uid     number,
  error#      number,
  status      number,               /* status: pending, resolved and ignored */
  action      varchar2(4000),                              /* action to take */              
  spare1      number,                                               /* spare */
  spare2      number,                                               /* spare */
  spare3      varchar2(30),                                         /* spare */
  cause       varchar2(64)                        /* cause text of the alert */
)
/

CREATE UNIQUE INDEX i_pdb_alert1 ON pdb_alert$(name, cause#, type#, line#)
/

CREATE INDEX i_pdb_alert2 ON pdb_alert$(name, cause#)
/

/* sequence for populating pdb_alert$.line# */
create sequence PDB_ALERT_SEQUENCE 
  increment by 1
  start with 1
  maxvalue 18446744073709551615 
  minvalue 1
  cycle 
  cache 10
  order
/

Rem This table is used to store names of XDB schema types whose names mismatch
Rem ROOT's. These types will need to be recreated in the PDB.
create table pdb_inv_type$
(
  owner     varchar2("M_IDEN"),                                /* type owner */
  type_name varchar2("M_IDEN")                                  /* type name */
)
/

Rem This table is used as the SPFILE for pluggable databases. The parameter
Rem values with spfile scope for each PDB are stored in the ROOT in this 
Rem table.
Rem NOTE: This table is created with nologging since standby can have different
Rem set of parameter values for the PDB.
create table pdb_spfile$
(
  db_uniq_name    varchar2(30)   not null,      /* DB Unique Name of the CDB */
  pdb_uid         number         not null,                 /* UID of the PDB */
  sid             varchar2(80)   not null,     /* sid for parameter setting, */
                                                          /* '*' if all sids */
  name            varchar2(80)   not null,          /* system parameter name */
  value$          varchar2(4000),                  /* system parameter value */
  comment$        varchar2(255),                 /* parameter update comment */
  spare1          number,                /* high-watermark for the parameter */
  spare2          number,                            /* flags for pdb spfile */
  spare3     varchar2("M_IDEN")                                     /* spare */
)
/

create unique index i_pdb_spfile_1
  on pdb_spfile$(db_uniq_name, pdb_uid, sid, name)
/

REM This table stores the last open state for every pdb on all instances.
Rem This table usually has data in root only.
create table pdbstate$
(
  inst_name   varchar2("M_IDEN") not null,                  /* instance name */
  pdb_guid    RAW(16),                                           /* pdb guid */
  pdb_uid     number not null,                              /* pdb unique ID */
  state       number not null,                            /* last open state */
  restricted  number not null,                                 /* restricted */
  spare1      number,                                               /* spare */
  spare2      number                                                /* spare */
)
/

CREATE UNIQUE INDEX i_pdbstate1 ON pdbstate$(inst_name, pdb_guid)
/

Rem This table stores per-PDB stats for CDB views
create table cdbvw_stats$
( objname       varchar2("M_IDEN") not null,                  /* object name */
  timestamp     date not null,                 /* stats collection timestamp */
  flags         number,  
  rowcnt        number,                                    /* number of rows */
  spare1        number,
  spare2        number,
  spare3        number,
  spare4        varchar2(1000),
  spare5        varchar2(1000),
  spare6        date          
)
  segment creation immediate
  storage (maxextents unlimited)
/

create unique index i_cdbvw_stats$_objname on cdbvw_stats$(objname)
  storage (maxextents unlimited)
/

REM undohist$ stores storage and interval attributes of every incarnation of 
REM an undo segment number. history for system undo segment is not available
REM as it is never dropped. It captures all columns of undo$ that are in use 
REM today (except status$ which varies in the lifetime of undo segment). 
REM In addition we store inc#, create-drop scn and time and 8 additional 
REM spares are added for . spare1 of undo$ is mapped to flag1 of undohist$.
REM
create table undohist$
( 
  us#         number not null,                        /* undo segment number */
  inc#        number not null,                         /* incarnation number */
  tsn         number not null,              /* useg header tablespace number */
  file#       number not null,           /* useg header relative file number */
  block#      number not null,                   /* useg header block number */
  crscnwrp    number not null,                          /* creation scn-wrap */
  crscnbas    number not null,                          /* creation scn-base */
  drscnwrp    number not null,                              /* drop scn-wrap */
  drscnbas    number not null,                              /* drop scn-base */
  crttime     number not null,                              /* creation time */
  drptime     number not null,                                  /* drop time */
  name        varchar2("M_IDEN_30") not null,   /* name of this undo segment */
  user#       number not null,        /* owner: 0 = SYS(PRIVATE), 1 = PUBLIC */
  scnwrp      number,                /* scnbas - scn base, scnwrp - scn wrap */
  scnbas      number,             /* highest commit time in rollback segment */
  xactsqn     number,                 /* highest transaction sequence number */
  undosqn     number,                  /* highest undo block sequence number */
  inst#       number,      /* parallel server instance that owns the segment */
  flags1      number,                                     /* spare1 of undo$ */
  spare1      number, 
  spare2      number,
  spare3      number, 
  spare4      number,
  spare5      number, 
  spare6      number,
  spare7      number,
  spare8      number
)
/

create unique index i_undohist1 on undohist$(us#, inc#)
/

REM This table stores some information about any common ddl changes that may
REM have happened in root when one or more of the pdbs were closed. This will
REM be consulted during the next read write open of the pdb to sync only the
REM changed information.
REM This table usually has data in root only.
create table pdb_sync$
(
  scnwrp      number not null,       /* scnbas - scn base, scnwrp - scn wrap */
  scnbas      number not null,                 /* scn for the current change */
  ctime       date not null,                                /* creation time */
  sqlstmt     varchar2("M_VCSZ"),/* responsible sql statement for the change */
  name        varchar2("M_IDEN") not null,    /* primary object name changed */
  auxname1    varchar2("M_IDEN"),                /* aux name1 for the object */
  auxname2    varchar2("M_IDEN"),                /* aux name2 for the object */
  opcode      number not null,                      /* opcode for the change */
  flags       number,                                               /* flags */
  longsqltxt  clob,                                         /* long sql text */
  replay#     number not null,      /* replay counter: 
                                    /*     in PDB,  total # of DDLs replayed */
                                    /*     in ROOT, total # of DDLs executed */
  creation#   number,    /* for dropped user: replay# of when it was created */
  spare3      varchar2("M_IDEN"),                                   /* spare */
  spare4      varchar2("M_IDEN"),                                   /* spare */
  spare5      varchar2("M_VCSZ"),                                   /* spare */
  spare6      number,                                               /* spare */
  spare7      number,                                               /* spare */
  spare8      number,                                               /* spare */
  sqlid       varchar2(13),              /* base 32 representation of sql id */
  appid#      number,                                      /* Application ID */
  ver#        number,     /* Internally generated application version number */
  patch#      number,                            /* Application patch number */
  app_status  number,                               /* Status of Application */
  sessserial# number                                      /* session serial# */
)
/

CREATE INDEX i_pdbsync1 ON pdb_sync$(replay#)
/

CREATE INDEX i_pdbsync2 on pdb_sync$(name)
/

CREATE INDEX i_pdbsync3 on pdb_sync$(bitand(flags,8))
/

CREATE INDEX i_pdbsync4 ON pdb_sync$(sessserial#)
/

Rem initial row to initialize replay counter. Use opcode -1
insert into pdb_sync$(scnwrp, scnbas, ctime, name, opcode, flags, replay#)
values(0, 0, sysdate, 'PDB$LASTREPLAY', -1, 0, 0)
/

REM This table is an auxiliary table to pdb_sync$.  pdb_sync$ will evolve to
REM store only the id for the sql statement. pdb_sync_stmt$ will then
REM store the mapping from sql id to full sql text.  Intent is to store the
REM same sql text only once.
CREATE TABLE pdb_sync_stmt$
(
  appid#      number,                                      /* Application id */
  sqlid       varchar2(13),              /* base 32 representation of sql id */
  sqltext     clob                                          /* full sql text */
)
/

CREATE UNIQUE INDEX i_pdb_sync_stmt$ ON pdb_sync_stmt$(appid#, sqlid)
/

REM This table stores attributes related to PDB lockdown profiles.
create table lockdown_prof$
(
  prof#       number not null,                                 /* profile id */
  ruletyp     varchar2("M_IDEN"),         /* rule type - stmt/feature/option */
  ruletyp#    number,                                        /* rule type id */
  ruleval     varchar2("M_IDEN"),                              /* rule value */
  ruleval#    number,                                       /* rule value id */
  clause      varchar2("M_IDEN"),                                  /* clause */
  option$     varchar2("M_IDEN"),                                  /* option */
  status      number,                             /* status - disable/enable */
  level#      number,                                  /* stmt/clause/option */
  value$      varchar2("M_VCSZ"),                           /* default value */
  ltime       timestamp,                           /* timestamp of the entry */
  spare1      number,                                               /* spare */
  spare2      number,                                               /* spare */
  spare3      number,                                               /* spare */
  spare4      number,                                               /* spare */
  spare5      timestamp,                                            /* spare */
  spare6      varchar2("M_IDEN"),                                   /* spare */
  spare7      varchar2("M_IDEN"),                                   /* spare */
  spare8      varchar2("M_VCSZ"),                                   /* spare */
  spare9      varchar2("M_VCSZ"),                                   /* spare */
  minval$     varchar2("M_VCSZ"),                   /* minimum allowed value */
  maxval$     varchar2("M_VCSZ"),                   /* maximum allowed value */
  list$       varchar2("M_VCSZ"),                  /* list of allowed values */
  con_uid     number not null,     /* container uid where profile is created */
  usertyp$    number                                         /* type of user */
)
/

CREATE INDEX i_lockdownprof1 ON
  lockdown_prof$(prof#, ruletyp#, ruleval, clause, option$)
/

CREATE INDEX i_lockdownprof2 ON
  lockdown_prof$(prof#, ruletyp#, ruleval)
/

CREATE INDEX i_lockdownprof3 ON
  lockdown_prof$(prof#, ruletyp#)
/

REM This table stores attributes related to View PDBS
create table view_pdb$
(
  con_uid     number,                    /* container Unique ID for view PDB */
  port        number,                             /* port number of view PDB */
  host        varchar2("M_XDBI"),                   /* host name of view PDB */
  service     varchar2(64),                      /* service name of view PDB */
  tgt_con_uid number                   /* container unique ID for target PDB */
)
/

REM This table stores attributes related to the remote PDBs of a Proxy PDB
create table proxy_remote$
(
  con_id#     number,                           /* container ID of Proxy PDB */
  name        varchar2("M_IDEN") not null,                 /* name for entry */
  flag        number,                                      /* flag for entry */
  remote_port number,                          /* port number for remote PDB */
  remote_host varchar2("M_XDBI"),                /* host name for remote PDB */
  remote_srvc varchar2("M_XDBI"),             /* service name for remote PDB */
  remote_user varchar2("M_IDEN"),                /* user name for remote PDB */
  spare1      number,
  spare2      number,
  spare3      number,
  spare4      varchar2(1000),
  spare5      varchar2(1000),
  spare6      date
)
/

REM This table stores plug attributes for tablespaces in a consolidated db
create table cdb_ts$                        /* ts table in a consolidated db */
(
  ts#           number not null,                        /* tablespace number */
  name          varchar2("M_IDEN") not null,           /* name of tablespace */
  con_id#       number not null,                             /* container ID */
  status$       number not null,                        /* tablespace status */
  cscnwrp       number not null,                           /* createscn wrap */
  cscnbas       number not null,                           /* createscn base */
  filecnt       number not null,             /* file count during pdb plugin */
  flags         number not null,                         /* additional flags */
  ptype         number not null,                   /* tablespace plugin type */
  spare1        number,                                             /* spare */
  spare2        number,                                             /* spare */
  spare3        number,                                             /* spare */
  spare4        number,                                             /* spare */
  spare5        varchar2(1000)                                      /* spare */
)
/

CREATE UNIQUE INDEX i_cdbts1 ON cdb_ts$(ts#, con_id#)
/


REM This table stores metadata related to PDB system statistics
create table pdb_stat$ (
  con_uid#    number not null,                       /* Unique ID of the PDB */
  inst_id     number not null,                                /* instance id */
  inst_name   varchar2("M_IDEN"),                           /* instance name */
  stat_name   varchar2("M_IDEN") not null,   /* name of the system statistic */
  stat_value  number not null,                         /* value of statistic */
  spare1      number,                                               /* spare */
  spare2      number,                                               /* spare */
  spare3      number,                                               /* spare */
  spare4      number,                                               /* spare */
  spare5      varchar2("M_VCSZ"),                                   /* spare */
  spare6      varchar2("M_VCSZ")                                    /* spare */
)
/

CREATE UNIQUE INDEX i_pdbstat1 ON pdb_stat$(con_uid#, inst_name, stat_name)
/

REM This table stores metadata related to status of PDB services
create table pdb_svc_state$ (
  inst_id       number not null,                              /* instance id */
  inst_name     varchar2("M_IDEN"),                         /* instance name */
  pdb_guid      RAW(16),                                         /* pdb guid */
  pdb_uid       number not null,                            /* pdb unique ID */
  svc_hash      number not null,                             /* service hash */
  spare1        number,                                             /* spare */
  spare2        number,                                             /* spare */
  spare3        number,                                             /* spare */
  spare4        number,                                             /* spare */
  spare5        varchar2("M_VCSZ"),                                 /* spare */
  spare6        varchar2("M_VCSZ")                                  /* spare */
)
/
  
CREATE UNIQUE INDEX i_pdbsvcstate1 
 ON pdb_svc_state$(inst_name, pdb_guid, svc_hash)
/

REM This table stores certain database properties in a CDB
create table cdb_props$
( con_uid#      number,                              /* unique id of the PDB */
  name          varchar2("M_IDEN") not null,                /* property name */
  value$        varchar2("M_VCSZ"),                        /* property value */
  comment$      varchar2("M_VCSZ"),               /* description of property */
  spare1        number,                                             /* spare */
  spare2        number,                                             /* spare */
  spare3        varchar2("M_VCSZ"),                                 /* spare */
  spare4        varchar2("M_VCSZ")                                  /* spare */
)
/

Rem system tablespace defaults to force logging
alter tablespace system force logging
/

REM This table stores attributes related to INMEMORY DISTRIBUTE FOR SERVICE
REM Key is <obj#,subpart#>
create table imsvc$ (
  obj#       number not null,                              /* object number */
  subpart#   number,             /*   subpartition number:                  */
                                 /*    non null for subpartition templates, */
                                 /*    null otherwise                       */
  dataobj#   number,                            /* data layer object number */
  file#      number,                          /* segment header file number */
  block#     number,                         /* segment header block number */
  ts#        number,                                   /* tablespace number */
  svcflags   number,                             /* distribute service type */
  svcname    varchar2(1000),                     /* distribute service name */
  spare1     number,                                               /* spare */
  spare2     number,                                               /* spare */
  spare3     varchar2(1000),                                       /* spare */
  spare4     varchar2(1000),                                       /* spare */
  spare5     date                                                  /* spare */
) 
/
create index i_imsvc1 on imsvc$(obj#,subpart#)
/

REM This table stores attributes related to INMEMORY DISTRIBUTE FOR SERVICE
REM for tablespaces.
REM Key is <ts#>
create table imsvcts$ (
  ts#        number,                                   /* tablespace number */
  svcflags   number,                             /* distribute service type */
  svcname    varchar2(1000),                     /* distribute service name */
  spare1     number,                                               /* spare */
  spare2     number,                                               /* spare */
  spare3     number,                                               /* spare */
  spare4     number,                                               /* spare */
  spare5     varchar2(1000),                                       /* spare */
  spare6     varchar2(1000),                                       /* spare */
  spare7     date                                                  /* spare */
) 
/
create index i_imsvcts1 on imsvcts$(ts#)
/

REM This table stores metadata related to INMEMORY ORDER BY clause
create table imorderby$ (
  obj#       number not null,                              /* object number */
  bo#        number,                                  /* base object number */
  file#      number,                          /* segment header file number */
  block#     number,                         /* segment header block number */
  ts#        number,                                   /* tablespace number */
  intcol#    number not null,                         /* user column number */
  position   number not null,          /* position of column in IMOB clause */
  spare1     number,                                               /* spare */
  spare2     number,                                               /* spare */
  spare3     number,                                               /* spare */
  spare4     number,                                               /* spare */
  spare5     varchar2(1000),                                       /* spare */
  spare6     varchar2(1000),                                       /* spare */
  spare7     date                                                  /* spare */
)
/

REM This table stores pdb create sql statement in CDB$ROOT
create table pdb_create$                   /* pdb creates in consolidated db */
(
  con_id#       number not null,                             /* container ID */
  con_uid       number not null,                            /* container UID */
  sqlstmt       clob,                                       /* sql statement */
  plugxml       blob,                                            /* plug XML */
  spare1        number,
  spare2        number,
  spare3        number,
  spare4        varchar2(1000),
  spare5        varchar2(4000)
)
/

-- 24524110 NOTE FOR ANY CHANGES TO TABLES FROM HERE TO "END 24524110"
-- These tables that are also in catappcontainertab.sql, run during upgrade.
-- Any changes to these tables require a corresponding ALTER TABLE
-- in catappcontainertab.sql. Do not change the existing CREATE TABLE
-- statements in catappcontainertab.sql. Use ALTER TABLE in addition to
-- the existing CREATE TABLE.
-- Additionally, all new columns need to be added to the end of the table,
-- so that an upgraded DB and newly-created DB have the same column ordering.

create sequence fed$stmt_seq start with 1 increment by 1 order;

-- see 24524110 NOTE above
create table fed$apps (
  app_name   varchar2(128),                              /* Application Name */
  appid#     number,                                       /* Application ID */
  ver#       number,      /* Internally generated application version number */
  app_status number,                                /* Status of Application */
/* 0x00000001 Disallow Sync of BEGIN block with no END */
/* 0x00000002 Propagate APP changes automatically */
/* 0x00000004 Enable rollback of APP changes */
/* 0x00000008 Internal App Container App */
/* 0x00000010 Internal CDB-wide System App */
/* 0x00000020 Internal CDB-wide Catalog App */
/* 0x00000040 Sync all */
/* 0x00000080 App is CDB-wide */
/* 0x00000100 App is in action */
/* 0x00000200 Reserved */
/* 0x00000400 Reserved */
/* 0x00000800 Reserved */
/* 0x00001000 Reserved */
/* 0x00002000 Reserved */
  flag       number,                                 /* Flag for application */
  srvn       varchar2(64),           /* service name for application capture */
  modn       varchar2(64),            /* module name for application capture */
  spare1     number,       /* default 0. UID of PDB if PDB's info is in Root */
  spare2     number,
  spare3     number,
  spare4     varchar2(1000),
  spare5     varchar2(1000),
  spare6     date
)
/

create index i_fed_apps$ on fed$apps(app_status);

create sequence fed$appid_seq
  start with 1
  increment by 1
/

-- see 24524110 NOTE above
create table fed$patches (
  appid#    number,                                        /* Application ID */
  patch#    number,                              /* Application patch number */
  minver#   number,       /* Internally generated application version number */
  status    number,                       /* 0 if installing, 1 if completed */
  cmnt      varchar2(4000),      /* comment describing the Application patch */
  spare1    number,                                        /* Checksum value */
  spare2    number,
  spare3    number,
  spare4    varchar2(1000),
  spare5    varchar2(1000),
  spare6    date
)
/
create unique index i_fed_patches$ on fed$patches(appid#, patch#);

-- see 24524110 NOTE above
create table fed$versions (
  appid#              number,                              /* Application ID */
  ver#                number,     /* Internally generated app version number */
  tgtver              varchar2(30),            /* Target Application Version */
  root_clone_con_uid# number,                   /* CON_UID of Fed Root Clone */
  cmnt                varchar2(4000), /* comment for the application version */
  spare1              number,                              /* Checksum value */
  spare2              number,
  spare3              number,
  spare4              varchar2(1000),
  spare5              varchar2(1000),
  spare6              date
)
/

-- see 24524110 NOTE above
create table fed$statement$errors (
  appid#     number,                                       /* Application ID */
  seq#       number,                 /* Internally generated sequence number */
  errornum   number,                      /* Error number when executing SQL */
  errormsg   varchar2(4000),             /* Error message when executing SQL */
  stime      date not null,                                     /* Sync time */
  spare1     number,
  spare2     number,
  spare3     number,
  spare4     varchar2(1000),
  spare5     varchar2(1000),
  spare6     date
)
/

-- see 24524110 NOTE above
create table fed$app$status (
  appid#    number,                                        /* Application ID */
  lastseq#  number,          /* Sequence number of "last" statement replayed */
  errorseq# number,        /* Sequence number of last statement before error */
  spare1    number,
  spare2    number,
  spare3    number,
  spare4    varchar2(1000),
  spare5    varchar2(1000),
  spare6    date,
  flag      number                            /* Flag for application status */
)
/

-- see 24524110 NOTE above
create table fed$binds (
  appid#     number,
  seq#       number,
  inc#       number,
  bind#      number,
  name       varchar2(128),
  datatype#  number,
  value      blob,
  spare1     number,
  spare2     number,
  spare3     number,
  spare4     varchar2(1000),
  spare5     varchar2(1000),
  spare6     date,
  spare7     blob,
  spare8     clob
)
/

create unique index i_fed_binds$ on fed$binds(appid#, seq#, inc#, bind#);

-- see 24524110 NOTE above
create table fed$editions (
  appid#        number,                                    /* Application ID */
  ver#          number,           /* Internally generated app version number */
  patch#        number,                          /* Application patch number */
  edition_name  varchar2(128),                               /* Edition name */
  edition_seq   number,    /* n-th edition associated with this app version,
                                                            counting from 0. */
  spare1        number,
  spare2        number,
  spare3        number,
  spare4        varchar2(1000),
  spare5        varchar2(1000),
  spare6        date
)
/
-- 24524110: see note

create sequence fed$sess_seq
  start with 1
  increment by 1
/

-- see 24524110 NOTE above
create table fed$dependency (
  appid#        number,                                    /* Application ID */
  parent_appid# number,                  /* Dependency parent Application ID */
  spare1        number,
  spare2        varchar2(1000),
  spare3        date
)
/

create sequence app$system$seq
  start with 1
  increment by 1
  nocache
/

-- END 24524110 NOTE

REM This table stores information about sensitive fixed tables
create table sensitive_fixed$
(
  name     varchar2("M_IDEN") not null,
  flag     number,
  spare1   number,
  spare2   number,
  spare3   varchar2(1000)
)
/

create index i_sensitive_fixed_n$ on sensitive_fixed$(name)
/

REM This table stores pdb snapshot information
create table pdb_snapshot$               /* pdb snapshots in consolidated db */
(
  con_id#       number not null,                             /* container ID */
  con_uid       number not null,                            /* container UID */
  snapname      varchar2("M_IDEN") not null,                /* snapshot name */
  snapscn       number not null,                             /* snapshot scn */
  prevsnapscn   number not null,                    /* previous snapshot scn */
  snaptime      number not null,                            /* snapshot time */
  prevsnaptime  number not null,                   /* previous snapshot time */
  archivepath   varchar2(4000) not null,        /* snapshot archive location */
  flags         number,                                             /* flags */
  spare1        number,
  spare2        number,
  spare3        number,
  spare4        varchar2(1000),
  spare5        varchar2(1000),
  spare6        varchar2(4000),
  spare7        date
)
/
create index i_pdbsnap1 on pdb_snapshot$(con_uid, snapscn)
/

create index i_pdbsnap2 on pdb_snapshot$(con_uid, snapname)
/

REM Table stores non-std sqls and en/disable info for plann maint draining.
create table connection_tests$   /* Tests which can be used for draining */
(
  predefined           number,          /* Test - Predefined(1) or Custom(0) */
  connection_test_type number,              /* SQL(0)/PING(1)/END_REQUEST(2) */
  sql_connection_test  varchar2(64),                                  /* SQL */
  service_name         varchar2(128),               /* Optional service name */
  enabled              number,             /* Test enabled(1) or disabled(0) */
  spare1               number,
  spare2               number,
  spare3               number,
  spare4               varchar2(1000),
  spare5               varchar2(1000),
  spare6               date
)
/
create unique index u_sql on 
            connection_tests$(connection_test_type, sql_connection_test)
/ 
insert into connection_tests$(predefined, connection_test_type, 
                              sql_connection_test, service_name, enabled) 
            values(1, 0, 'SELECT 1 FROM DUAL', '', 1)
/
insert into connection_tests$(predefined, connection_test_type, 
                              sql_connection_test, service_name, enabled) 
            values(1, 0, 'SELECT COUNT(*) FROM DUAL', '', 1)
/
insert into connection_tests$(predefined, connection_test_type, 
                              sql_connection_test, service_name, enabled) 
            values(1, 0, 'SELECT 1', '', 1)
/ 
insert into connection_tests$(predefined, connection_test_type, 
                              sql_connection_test, service_name, enabled) 
            values(1, 0, 'BEGIN NULL;END', '', 1)
/
insert into connection_tests$(predefined, connection_test_type, 
                              sql_connection_test, service_name, enabled) 
            values(1, 1, 'NA', '', 0)
/
insert into connection_tests$(predefined, connection_test_type, 
                              sql_connection_test, service_name, enabled) 
            values(1, 2, 'NA', '', 0)
/
commit
/

