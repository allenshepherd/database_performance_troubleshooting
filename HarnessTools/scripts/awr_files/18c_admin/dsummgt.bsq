REM   MODIFIED (MM/DD/YY)
REM   liding    06/05/15 - Bug 21049500: MV refresh usage stats
REM   sramakri  04/03/15 - bug-20558588
REM   prakumar  01/07/14 - Proj# 39358: Add redef_object_backup$
REM   minwei    02/22/13 - Add new column to redef_status
REM   panzho    05/29/12 - bug 14118698
REM   panzho    05/17/12 - Sync Refresh feature tracking
REM   liding    03/29/12 - bug 13904132: MV refresh usage tracking
REM   brwolf    11/29/11 - 32733: evaluation edition
REM   mziauddi  08/20/11 - document flag bits used in sumdetail$
REM   xiaobma   06/03/11 - Sync Refresh syncref$_stlog_stats
REM   mziauddi  01/01/11 - add zmapscale to sum$
REM   sramakri  04/28/11 - Sync Refresh catalog tables
REM   xiaobma   03/24/11 - bug 11901181
REM   jklein    08/01/05 - creation
create table sum$                                           /* summary table */
( obj#             number not null,                         /* object number */
  containerobj#    number not null,    /* object number of the container tab */
  containertype    number not null,       /* type of container - snap, table */
  containernam     varchar2("M_IDEN"),                  /* name of container */
  fullrefreshtim   number,             /* number in seconds for full refresh */
  Increfreshtim    number,             /* number in seconds for full refresh */
  lastrefreshscn   number,             /* scn of last transaction to refresh */
  lastrefreshdate  date,              /* date of last transaction to refresh */
  refreshmode      number,                   /* 0=none, 1=any, 2=inc, 3=full */
  pflags           number,                /* summary properties (bit flags): */
                                                /* refer to  QSMKSANA* flags */
  xpflags          number,                            /* extension to pflags */
  mflags           number,                          /* summary mutable flags */
                                              /* 0x01 summary is known stale */
                                                 /* 0x02 summary is unusable */
                                                 /* 0x04 summary is disabled */
  numdetailtab     integer,                       /* number of detail tables */
  numaggregates    integer,                            /* number of measures */
  numkeycolumns    integer,                      /* keys are group by fields */
  numjoins         integer,                    /* number of joins in summary */
  numinlines       integer,             /* number of inline views in summary */
  numwhrnodes      integer,   /* number of nodes in the where predicate tree */
  numhavnodes      integer,  /* number of nodes in the having predicate tree */
  numqbnodes       integer,       /* number of nodes in the query block tree */
  qbcmarker        integer,        /* qbc marker idx postion in the sel list */
  sumtextlen       number,                            /* length of text body */
  sumtext          long,                        /* text from 'select' onward */
  fromoffset       number not null,        /* offset in bytes to FROM clause */
  fromlen          number not null,   /* length from the F to the last table */
  metaversion      number not null,   /* version of this the canonical forms */
  objcount         number not null,           /* number of dependant objects */
  markerdty        integer,     /* data type of the qbc marker (for setop MV)*/
                                         /* 1 for character string */
                                         /* 2 for number */
                                         /* 3 for integer ... */
  rw_name          varchar2("M_IDEN"),    /* name of the rewrite equivalence */
  src_stmt         clob,              /* source statement for rw equivalence */
  dest_stmt        clob,         /* destination statement for rw equivalence */
  rw_mode          integer,               /* rewrite mode for rw equivalence */
                                                              /* disable = 0 */
                                                           /* text_match = 1 */
                                                              /* general = 2 */
                                                            /* recursive = 3 */
  spare1           number,   /* commitrefresh_scn, scn when refresh commited */
  spare2           number,
  spare3           varchar2(1000),
  spare4           date,
  zmapscale        number,                          /* zone map scale factor */
  evaledition#     number,                             /* evaluation edition */
  unusablebefore#  number,                        /* unusable before edition */
  unusablebeginning# number                    /* unusable beginning edition */
)
/
create unique index i_sum$_1 on sum$(obj#)
/
create table sumdetail$            /* summary detail table */
( sumobj#       number not null,   /* object number */
  detailobj#    number not null,   /* obj number of detail table */
  qbcid         number not null,   /* query block id */
  detailobjtype number,            /* 1=table,2=view,3=snap,4=cont. table */
  detailalias   varchar2("M_IDEN"),/* alias if used */
  refreshscn    number,            /* scn of last refresh */
  detaileut     number,            /* detail tablew EUT flag */
  spare1        number,
  spare2        number,
  spare3        varchar2(1000),
  spare4        date,
  inline#       number,            /* inline view number */
  instance#     number,            /* instance # for duplicate table */
  dataless      number,            /* is the table dataless ? */
  tabscnctr     number,            /* detail table SCN counter value relative
                                    * to which the summary was last complete
                                    * refreshed.
                                    */
  flags         number
  /* The following bits are defined by qsmqsmd and qsmksdet structs */
  /*   0x01 : object from an inline view (bug 11901181) */
  /*   0x02 : object represents zonemap fact table */
)
/
create index i_sumdetail$_1 on sumdetail$(sumobj#)
/
create index i_sumdetail$_2 on sumdetail$(detailobj#)
/

create table suminline$            /* summary inline view table */
( sumobj#       number not null,   /* object number */
  inline#       number not null,   /* inline view unique identifier */
  textspos      number not null,   /* inline view offset starting position */
  textlen       number not null,   /* inline view text length */
  text          long   not null,   /* inline view text */
  hashval       number not null,   /* hash value generateed from the inline */
                                   /* view text */    
  qbcid         number not null,   /* query block id */
  spare1        number,
  spare2        number,
  spare3        varchar2(1000),
  spare4        date,
  instance#     number             /* instance # for duplicate inline view */
)
/
create index i_suminline$_1 on suminline$(sumobj#)
/
create index i_suminline$_2 on suminline$(inline#)
/
create index i_suminline$_3 on suminline$(hashval)
/

create table sumkey$             /* summary key table */
( sumobj#       number not null, /* parent summary obj */
  sumcolpos#    number not null, /* position of column in select list */
  containercol# number not null, /* pos. in container where stored */
  detailobj#    number not null, /* detail table object from FROM */
  qbcid         number not null, /* query block id */
  detailobjtype number,          /* detail table type - see sumdetail$ */
  detailcol#    number,          /* col number within detail table */
  groupingpos#  number,          /* pos. in GB clause */
  exprlen       number,
  expression    varchar2(4000),
  textlen       number,
  text          long,
  detailcolfunction number,      /* 0 = regular, 1 = partition key */
                                 /* 2 = partition marker, 3 = rowid */
  spare1        number,
  spare2        number,          /* length of column datatype info text */
  spare3        varchar2(1000),  /* column datatype info text */
  spare4        date,
  nodetype      number,          /* node type - see qkegstyp */
  ordinalpos    number,          /* for GSets - ordinal position */
  parentpos     number,          /* for GSets - parent postion (ordinal) */
  inline#       number,          /* inline view number */
  instance#     number           /* instance # for duplicate table */
)
/
create unique index i_sumkey$_1 on sumkey$
  (sumobj#,sumcolpos#,groupingpos#,ordinalpos,qbcid)
/
create table sumagg$             /* summary aggregate table */
( sumobj#       number not null, /* parent summary obj */
  sumcolpos#    number not null, /* position of column in select list */
  containercol# number not null, /* pos. in container where stored */
  qbcid         number not null, /* query block id */ 
  aggfunction   integer,         /* type of aggregate function */
  flags         number,          /* sumagg properties (bit flags): */
                                 /* 0x01=distinct aggregate */
  exprlen       number,          /* len of the canonical form */
  expression    varchar2(4000),  /* expr in canonical form */
  textlen       number,          /* len of aggregate text */
  aggtext       long,            /* text of agg. expression */
  spare1        number,
  spare2        number,
  spare3        varchar2(1000),
  spare4        date,
  agginfo       varchar2(4000),  /* info about aggs like start of args */
  agginfolen    number           /* length of agginfo */
)
/
create unique index i_sumagg$_1 on sumagg$(sumobj#,sumcolpos#,qbcid)
/
create table sumjoin$             /* summary join table */
( sumobj#       number not null,  /* Object number of the summary */
  tab1obj#      number not null,  /* Object number of the first table */
  tab1col#      number not null,  /* Column number in the first table */
  tab2obj#      number not null,  /* Object number of the second table */
  tab2col#      number not null,  /* Column number of second table */
  qbcid         number not null,  /* query block id */
  joinop        integer,          /* Op code as defined in opndef.h (OPTTEQ) */
  flags         number,           /* currently unused */
  spare1        number,
  spare2        number,
  spare3        varchar2(1000),
  spare4        date,
  inline1#      number,           /* left inline view number */
  inline2#      number,           /* right inline view number */
  instance1#    number,           /* instance # for tabobj1 */
  instance2#    number            /* instance # for tabobj2 */
)
/

create index i_sumjoin$_1 on sumjoin$(sumobj#,tab1obj#)
/
create table sumdep$                             /* summary dependency table */
( sumobj#       number not null,                  /* dependent object number */
  order#        number not null,                             /* order number */
  p_obj#        number not null,                     /* parent object number */
  p_type        number not null,                       /* parent object type */
  qbcid         number not null,                           /* query block id */
  p_ref_time    date,                            /* parent refresh timestamp */
  p_ref_scn     number,                                /* parent refresh scn */
  flags         number,
  inline#       number,                                     /* inline view # */
  instance#     number,                            /* inline view instance # */
  syn_own       varchar2("M_IDEN"),   /* owner of the synonym for base table */
  syn_name      varchar2("M_IDEN"),    /* name of the synonym for base table */
  syn_master    number,           /* order number that the synonym points to */
  vw_query      long,                              /* text of the view query */
  vw_query_len  number                      /* length of the view query text */
)
/
create index i_sumdep$_1 on sumdep$(sumobj#,order#)
/
create index i_sumdep$_2 on sumdep$(p_obj#,p_type)
/
create table sumpred$                    /* summary where/having pred tree */
(sumobj#           number not null,      /* summary object number */
 nodeid            number not null,      /* id that identifies a tree node */
 pnodeid           number not null,      /* parent node id */
 clauseid          integer not null,     /* caluse type: WHERE, HAVING, EUT..*/
 nodetype          integer not null,     /* AND, OR, COL_REL_CONST ... */
 qbcid             number not null,      /* query block id */
 numchild          integer,            /* num. of children for AND, OR nodes */
 relop             integer,              /* <,>,...,RP, IN-LIST..*/
 loptype           integer,              /* left operand type: COL,AGG,...*/
 roptype           integer,              /* right operand type: COL,AGG,...*/
 ldobj#            number,               /* left detail table object number */
 rdobj#            number,               /* right detail table object number */
 lcolid            number,               /* left column id if loptype=COL */
 rcolid            number,               /* right column id if roptype=COL */
 laggtype          integer,              /* OPTTYPE for left operand if AGG. */
 raggtype          integer,             /* OPTTYPE for right operand if AGG. */
 lcanotxt          varchar2(4000),       /* left operand normalized string */
 rcanotxt          varchar2(4000),       /* right operand normalized string */
 lcanotxtlen       integer,              /* left operand string length */
 rcanotxtlen       integer,              /* right operand string length */ 
 ltxt              varchar2(4000),       /* string for left expr */
 rtxt              varchar2(4000),       /* string fot right expr */ 
 ltxtlen           integer,              /* left expr length */
 rtxtlen           integer,              /* right expr length */
 value             long,                 /* value of oper. if optype = CONST */
 valuelen          integer,              /* value length */
 numval            integer,              /* number of values in in-list */
 colpos            integer,              /* used for multi-column in-lists */
 lflags            number,               /* left operand miscellaneous info */
 rflags            number,               /* right operand miscellaneous info */
 linline#          number,               /* left inline view number */
 rinline#          number,               /* right inline view number */
 linstance#        number,               /* instance # for left detail tab */
 rinstance#        number                /* instance # for right detail tab */
)
/
create index i_sumpred$_1 on sumpred$(sumobj#,clauseid)
/
create table sumqb$                      /* summary query block tree */
(sumobj#           number not null,      /* summary object number */
 nodeid            number not null,      /* node id */
 pflags            number,               /* persistent flags for query block */
 xpflags           number,               /* extented persistent flags */ 
 sflags            number,               /* snapshot semantic flags */
 state             number,               /* state info */
 text              long,                 /* normalized text */
 textlen           number,               /* length of the text */
 marker            varchar2(4000),       /* qbc marker value */
 markerlen         number,               /* length of the marker */
 hashval           number,               /* hash value */
 hashval2          number,               /* 2nd hash value */
 rorder            number,               /* node order relative to root */
 sorder            number,         /* node order relative to root of subtree */
 leafcnt           number,               /* number of leaf nodes */
 orignode          number,               /* node id of subtree */
 parent            number,               /* parent node id */
 opttyp            number,               /* operator type */
 selcnt            number,               /* number of select list items */
 frompo            number,               /* FROM position in text */
 flags             number,               /* misc info flags */
 numdetailtab      integer,              /* number of detail tables */
 numaggregates     integer,              /* number of measures */
 numkeycolumns     integer,              /* keys are group by fields */
 numjoins          integer,              /* number of joins in summary */
 numinlines        integer,             /* number of inline views in summary */
 numwhrnodes       integer,   /* number of nodes in the where predicate tree */
 numhavnodes       integer   /* number of nodes in the having predicate tree */
)
/
create index i_sumqb$_1 on sumqb$(nodeid)
/
create index i_sumqb$_2 on sumqb$(hashval)
/
create index i_sumqb$_3 on sumqb$(hashval2)
/
create table hier$                  /* a hierarchy */
( dimobj#       number not null,    /* object number */
  hierid#       number not null,    /* unique number within dimension */
  hiername      varchar2("M_IDEN"), /* text name or hierarchy */
  spare1        number,
  spare2        number,
  spare3        varchar2(1000),
  spare4        date
)
/
create unique index i_hier$_1 on hier$(dimobj#,hierid#)
/
create table hierlevel$            /* identifies a level in a hierarchy */
( dimobj#       number not null,   /* object number */
  hierid#       number not null,   /* unique number of the hierarchy */
  pos#          number not null,   /* postition of level in hierarchy */
  levelid#      number not null,   /* id of the level */
  joinkeyid#    number,            /* join key - if levels are from 2 tables */
  spare1        number,
  spare2        number,
  spare3        varchar2(1000),
  spare4        date
)
/
create index i_hierlevel$_1 on hierlevel$(dimobj#,hierid#)
/
create table dim$                     /* dimension table */
( obj#             number not null,   /* object number */
  dimtextlen       number,            /* length of the dimension text */
  dimtext          long,
  flags            number,            /* currently only maintains force */
  numlevels        number,            /* number or levels */
  numlevkeys       number,            /* number of level keys */
  numjoinkeys      number,            /* number of join keys */
  numhier          number,            /* number or hierarchies */
  numhierlv        number,            /* number of hierarchy levels */
  numattr          number,            /* number of attributes */
  spare1           number,
  spare2           number,
  spare3           varchar2(1000),
  spare4           date
)
/
create unique index i_dim$_1 on dim$(obj#)
/
create table dimlevel$              /* a dimension level */
( dimobj#       number not null,    /* object number */
  levelid#      number not null,    /* unique number within dimension */
  levelname     varchar2("M_IDEN"), /* text name associated with the level */
  spare1        number,
  spare2        number,
  spare3        varchar2(1000),
  spare4        date,
  flags         number default 0    /* flags: 0x01 = SKIP WHEN NULL */
)
/
create unique index i_dimlevel$_1 on dimlevel$(dimobj#,levelid#)
/
create table dimlevelkey$          /* the columns of a level */
( dimobj#       number not null,   /* object number */
  levelid#      number not null,   /* unique number within dimension */
  keypos#       number not null,   /* postition of column in the key */
  detailobj#    number,            /* detail table object */
  col#          number,            /* col number within detail table */
  spare1        number,
  spare2        number,
  spare3        varchar2(1000),
  spare4        date
)
/
create index i_dimlevelkey$_1 on dimlevelkey$(dimobj#,levelid#)
/
create index i_dimlevelkey$_2 on dimlevelkey$(detailobj#,col#)
/
create table dimjoinkey$           /* describes a join in a dimension */
( dimobj#       number not null,   /* object number */
  joinkeyid#    number not null,   /* unique number within dimension */
  keypos#       number not null,   /* postition of column in the key */
  hierid#       number,            /* number of hier which this key links */
  levelid#      number,            /* number of hier which this key links */
  detailobj#    number,            /* detail table object */
  col#          number,            /* col number within detail table */
  chdlevid#     number,            /* number of the child level */
  spare1        number,
  spare2        number,
  spare3        varchar2(1000),
  spare4        date
)
/
create index i_dimjoinkey$_1 on dimjoinkey$(dimobj#,joinkeyid#)
/
create index i_dimjoinkey$_2 on dimjoinkey$(detailobj#,col#)
/ 
create table dimattr$               /* describes attributes of a dimension */
( dimobj#       number not null,    /* object number */
  levelid#      number not null,    /* id of the level */
  detailobj#    number not null,    /* detail table object */
  col#          number,             /* col number within detail table */
  attname       varchar2("M_IDEN"), /* name of the attribute */
  spare1        number,
  spare2        number,
  spare3        varchar2(1000),
  spare4        date
)
/
create index i_dimattr$_1 on dimattr$(dimobj#,levelid#)
/
create index i_dimattr$_2 on dimattr$(detailobj#,col#)
/

REM 
REM SYNC REFRESH CATALOG TABLES
REM

--
-- syncref$_groups
--
-- This table stores information on the sync-refresh-groups. It is populated 
-- at register_mviews time and deleted according to the purge policy.
--
-- The lock_flag field is used to enforce sync-refresh-group-locking with 
-- the locking_primitive implemented with Oracle row-level locks.
--

create table syncref$_groups
(
 group_id	    number not null primary key,             /* the group-id */
 lock_flag          number not null            /* 0 - not locked, 1 - locked */
);

--
-- syncref$_table_info
--
-- This table stores information on the base-tables of the MVs registered 
-- for sync refresh. It is populated during staging-log DDL. A row is inserted
-- when the staging-log is created and deleted when the log is dropped or 
-- altered to an ordinary MV-log.
--

create table syncref$_table_info
(
  table_obj#        number         not null primary key, 
  staging_log_obj#  number         not null
);

--
-- syncref$_objects
--
-- This table stores information on the objects (tables and MV's) registered 
-- for sync refresh. It can contain multiple rows for the same obj# but only 
-- one of them can have current_group_flag = TRUE; all others must have  
-- current_group_flag = FALSE.
-- A row is entered into this table whenever an MV is either registered 
-- or unregistered.
--

create table syncref$_objects
(
 obj#               number not null, 
 object_type_flag   number not null,                       /* table or mview */
 group_id	    number not null,
 current_group_flag number not null      /* 1 ==> current sync-refresh-group */
                                        /* 0 ==> obsolete sync-refresh-group */
);

--
-- syncref$_partn_ops
--
-- This table stores information on the partition operations registered 
-- on the base-tables of  the MV's registered for sync refresh. 
-- The usage of this table is quite straight-forward.  It is populated at
-- REGISTER_PARTITION_OPERATION time and rows deleted when pmops are 
-- unregistered or the refresh is completed.
--

create table syncref$_partn_ops
(
 table_obj#         number  not null, 
 partition_op	    varchar2(128) not null,  /* exchange or drop or  truncate */
 partition_name	    varchar2(128)    not null,    /* name of the partition to */
                                                              /* be changed. */
 outside_table_schema_name  varchar2(128), /*schema in which the outside-table*/
                                     /* (for exchange partition) was created */
 outside_table_name   varchar2(128)              /* name of the outside-table */
                                                 /* (for exchange partition) */
);

--
-- syncref$_group_status
-- 
-- This table stores information on the overall status of the prepare_refresh (PR)
-- and  execute_refresh (ER) operations and the current-state of the operation for 
-- each run of a group. 
-- An entry is created in this table for a refresh-group when the 
-- prepare-refresh is started and it is deleted according to the 
-- refresh-history retention policy.
-- The state and status of the group during prepare- and execute-refresh 
-- is constantly updated during those operations. The usage of the cur_run_xxx
-- fields to maintain the state-transition-table have been discussed in 
-- Section 3.4 and is not repeated here.
--
-- The current_step field records the stmt-number in syncref$_step_status
-- which is currently executing at PR time. It is not used/set for ER.
--
--

create table syncref$_group_status
(
 group_id	    number not null,                  /* the group-id of the */
                      /* sync-refresh-group whose status is being described. */
 cur_run_flag       number not null,                 /* 0 - old, 1 - current */
 cur_run_opn        number not null,              /* 1 - PREPARE, 2- EXECUTE */
 cur_run_status     number not null,            /* 0 - RUNNING, 1- COMPLETE, */
                                  /* 2 - ERROR-SOFT, 3- ERROR-HARD, 4 -ABORT */
                                                              /* 5 - PARTIAL */
 num_prepare_steps  number not null,
 num_execute_steps  number not null,
 current_step       number not null,              /* used by prepare_refresh */
 num_abortpr_steps  number not null,
 num_tbls           number not null,     /* the number of tables in the group */
 num_mvs            number not null,     /* the number of mviews in the group */
 base_tbls_refr_status  number not null,               /* 0 - NOT PROCESSED, */
                                                  /* 1 - COMPLETE, 4 - ABORT */
 num_mvs_completed  number,  /*the number of mvs which have completed refresh*/
 num_mvs_aborted    number,  /* the number of mvs which have aborted refresh */
 error_number	    number,                           /* error number if any */
 error_message	    varchar2(4000),                  /* error message if any */
 prepare_start_time  date,                  /* start-time of prepare_refresh */
 prepare_end_time    date,                    /* end-time of prepare_refresh */
 execute_start_time  date,                  /* start-time of execute_refresh */
 execute_end_time    date,                    /* end-time of execute_refresh */
 owner#	             number not null               /* the owner of the group */
);

--
-- syncref$_object_status
--
-- This table is the object-level counterpart of syncref$_group_status.  
-- It stores information on the status of each object during the 
-- prepare_refresh and  execute_refresh operations 
--
-- An entry is created in this table for the objects in the sync-refresh-group
-- at prepare-refresh time with  cur_run_flag = 1 any previous entry for the 
-- group is marked with cur_run_flag = 0
--
-- The status of the object is updated by  execute-refresh to COMPLETE or ABORT
--
-- The field canonical_order is a canonical_ordering of the objects in the 
-- group in the order they are to be processed for Data-Validation. 
-- It is assigned at the initialization time of prepare_refresh.
--
-- The status field has the following values:
--   0 - NOT PROCESSED, 1 - COMPLETE, 4 - ABORT 
--  NOT PROCESSED  means refresh has not occurred or is running
--

create table syncref$_object_status
(
 obj#               number not null, 
 cur_run_flag       number not null,                 /* 0 - old, 1 - current */
 group_id	    number not null,                  /* the group-id of the */
                         /* sync-refresh-group to which this object belongs. */
 canonical_order    number,                     /* canonical ordering number */
 status	            number not null,            /* status - see values above */
 num_exch_partns    number,          /* number of partitions to be exchanged */
 num_inplace_partns number,                          /* number of partitions */
                         /* to be modified in-place with incremental refresh */
 num_inplace_rows   number,                          /* number of rows to be */
                              /* modified in-place with incremental refresh. */
 error_number	    number,                           /* error number if any */
 error_message	    varchar2(4000),                  /* error message if any */
 last_modified_time   date        /* timestamp of last update, used by purge */
);

-- 
-- syncref$_step_status
--
-- This table maintains the status of each step of each current operation 
-- on  a group. The usage of this table in conjunction with the current_step 
-- field in syncref$_group_status is described in Section 3.3.
-- This table is populated at PREPARE_REFRESH initialization time. 
-- It represents the plan for the prepare- and execute operations, as well 
-- the plan for undoing the actions in case of an ABORT. If an error occurs 
-- at a step, processing will stop and if the operation is resumed, we will 
-- pick up processing from the place we stopped.
--
-- The prepare_refresh and execute_refresh are broken into a sequence  
-- of steps, each associated with a SQL statement which must be  executed. 
-- These steps are computed at the beginning of prepare_refresh  and recorded 
-- in the syncref$_step_status table. In syncref$_group_status, 
-- the num_prepare_steps and num_execute_steps record the values of the 
-- number of steps in the two operations 
-- 
-- The field current_step  in syncref$_group_status stores  the number 
-- of the current step  being processed. If processing stops due to a 
-- soft error, and user resumes the refresh-operation, the operation will 
-- begin from the current-step. If the user chooses to abort the operation, 
-- the  abort-refresh will execute the undo_statements in the reverse-order 
-- starting from the predecessor of the current step all the way to the 
-- first step. 
--
-- New fields added on 6/7/2011:
-- stmt_grp_type - the statement-group-type, used internally by Sync Refresh 
--                 and documented in kkzf2.c
-- stmt_type     - the statement-type, used internally by Sync Refresh 
--                 and documented in kkzf2.c
-- set_seq-num - the sequence number obtained from the syncref_step_seq$
--               sequence. It is being set currently but used later. It
--               could be useful for consistency check on stmt_step.
-- stmt_step  - is the renamed "step" field. It starts at 1 .. max_steps
--              for the operation
-- aux_obj#   - set to 0 currentl. Not used. Maybe useful later
-- owner      - owner of the the object being operated on 
-- obj_name   - name of object (table or mv) 
-- aux_obj_name - np_name (i.e. new-partition-name) or ot_name (outside-
--               table-name). The former is for the fact-table, the latter
--               for mv's.
-- The owner, obj_name are set but not used currently.
-- The aux_obj_name is set and used later in instantiating the 
-- "disable foreign key" statement on new partitions. Since the foreign-keys
-- are given system-generated names which are generated only at 
-- execute_refresh (ER) time, they are not known at prepare_refresh (PR) time,
-- so PR generates these statements with a "%s" placeholder which is filled
-- at ER time after the foreign-key constraints have been created enabled.
--
create table syncref$_step_status
(
 group_id            number not null,                  /* the group-id of the */
                       /* sync-refresh-group whose status is being described. */
 operation           number not null,                    /* PREPARE, EXECUTE, */
 step_seq_num        number not null,           /* set from syncref_step_seq$ */
 stmt_grp_type       number not null,     /* stmt_grp-number of the operation */
 stmt_type           number not null,     /* stmt_grp-number of the operation */
 stmt_step           number not null,         /* step-number of the operation */
                                                             /* starts with 1 */
 obj#                number not null,    /* the object-number of object being */
                                                     /* processed in the step */
 aux_obj#            number,   /* the object-number of auxillary object being */
                                                     /* processed in the step */
 statement           clob,                                       /* statement */
 undo_statement      clob,    /* statement in case statement is being aborted */
 status              number not null,        /* completed, error, not-started */
 owner               varchar2(128),
 obj_name            varchar2(128),
 aux_obj_name        varchar2(128)
);

-- 
-- syncref$_log_exceptions
--
-- This table maintains information on exceptions in the staging-log 
-- detected by prepare_staging_log or prepare_refresh. 
--

create table syncref$_log_exceptions 
(
 table_obj#         number not null, 
 staging_log_obj#   number not null,
 bad_rowid	    rowid not null,                          /* rowid of the */
                                         /* offending row in the staging log */
 error_number	   number,                                   /* error number */
 error_message	   varchar2(4000)                           /* error message */
);

--
-- syncref$_parameters
--
-- This table stores  information on parameters which can be set by user 
-- to affect sync-refresh behavior. Current we have only parameter as shown 
-- below. This table can also be used if we need to ship patches to the 
-- customer as an alternative to the RDBMS global system parameters 
-- (defined in prm.h).
--
 
create table syncref$_parameters
(
 parameter_name     varchar2(256) not null primary key,
 num_value          number,
 str_value          varchar2(4000),                    /* not used currently */
 flags              number                             /* not used currently */
);

insert into syncref$_parameters values ('REFRESH_HISTORY_STATS_RETENTION', 31, NULL, 0);


--
-- syncref$_er_refgrps
--
-- Refresh-groups used by ER 
-- When ER is resumed or aborted, we construct a ref_list containing the 
-- refresh sub-group. Each sub-group is refreshed atomically, in one
-- transaction. The base tables are all in the first sub-group with
-- ref_grp_num = 0;  each mv is in a different group and its sumobjn 
-- is stored in it's eref. 
--
-- The sub-groups are constructed and stored on disk on a fresh ER
-- The term sub-group and refgrp are used interchangeably below.
--
-- The status field has the following values:
--   0 - NOT PROCESSED, 1 - COMPLETE, 4 - ABORT 
--
--  NOT PROCESSED  means refresh has not occurred or is running
--

create table syncref$_er_refgrps
(
 group_id	    number not null,                  /* the group-id of the */
                         /* sync-refresh-group to which this object belongs. */
 ref_grp_num	    number not null,             /* the number of the refgrp */
                        /* 0 - base_table_group; 1 - num_mvs  for mv_refgrps */
 mv_obj#            number not null,                   /* obj# for mv_refgrp */
 status	            number not null,            /* status - see values above */
 first_stmt         number not null,           /* first_stmt in the sub-group */
 last_stmt          number not null            /* last_stmt in the sub-group */
);

--
-- syncref$_soft_errors
--
-- The errors stored in this table are used to classify an error as hard or
-- soft. We populate this table at database-creation time. We read from this
-- table at prepare_refresh time. This table will be provided to Support.
--
-- Note: a soft error is an error from which the user can resume PR
--

create table syncref$_soft_errors 
(
 error number primary key
);

--
-- Mark 1536 as a soft-error. This corresponds to:
-- ORA-01536: space quota exceeded for tablespace '%s'
--

insert into syncref$_soft_errors (error) values (1536);


-- 
-- syncref$_stlog_stats
--
-- This table stores information about the staging table statistics including
-- number of rows to be inserted, deleted and updated.
--

create table syncref$_stlog_stats
(
  table_obj#        number         not null primary key,
  num_inserts       number         not null,
  num_deletes       number         not null,
  num_updates       number         not null, 
  psl_mode          number         not null /* 0=ENFORCED; */
                                   /* 1=INSERT_TRUSTED; */
                                   /* 2=DELETE_TRUSTED; */
                                   /* 4=UPDATE_TRUSTED; */
                                   /* 7=TRUSTED;   */
);

--
-- syncref_group_id_seq$
--
-- This sequence is used to assign group-ids to Sync Refresh groups at
-- mv-registration time. Note group-ids may also change during the 
-- unregister_mviews call.
--

create sequence syncref_group_id_seq$                   /* syncref group_id sequence */
  increment by 1
  start with 1
  minvalue 1
  maxvalue 2147483647     /* max value that is guaranteed to fit into an SB4 */
  nocycle
/

--
-- syncref_group_id_seq$
--
-- This sequence is used to assign the step_seq_num at PR time.
-- It could be useful as a check on the step_seq assigned by PR
--
-- 

create sequence syncref_step_seq$
  increment by 1
  start with 1
  minvalue 1
  maxvalue 2147483647     /* max value that is guaranteed to fit into an SB4 */
  nocycle;

REM 
REM SYNC REFRESH END
REM

grant create table to system
/
grant create snapshot to system
/
grant select any table to system
/
grant global query rewrite to system
/
rem sequence used to generate ids for online redefinitions and its steps
create sequence redef_seq$ increment by 1 start with 1 nocycle
/

rem table to store the redefinition metadata
create table redef$(
  id      integer            not null,                    /* redefinition id */
  name    varchar2("M_IDEN") not null,                /* transformation name */
  state   integer            not null,  /* current state of the redefinition */
  flag    integer                                /* flag (internal use only) */
)
/ 
create unique index ui_redef_id$ on redef$(id)
/
create unique index ui_redef_name$ on redef$(name)
/

rem table to store the information about the objects involved while executing
rem a redefinition
create table redef_object$(
  redef_id       integer            not null,             /* redefinition id */
  obj_type       integer            not null,                 /* object type */
  obj_owner      varchar2("M_IDEN") not null,       /* original object owner */
  obj_name       varchar2("M_IDEN") not null,        /* original object name */
  int_obj_owner  varchar2("M_IDEN"),          /* interim/cloned object owner */
  int_obj_name   varchar2("M_IDEN"),           /* interim/cloned object name */
  bt_owner       varchar2("M_IDEN"),                     /* base table owner */
  bt_name        varchar2("M_IDEN"),                      /* base table name */
  genflag        integer,                        /* flag (internal use only) */
  typflag        integer       /* obj type specific flag (internal use only) */
)   
/
rem any changes to the below index should have a corresponding change to 
rem index, i_redef_object_backup$
create index i_redef_object$ on
 redef_object$(redef_id, obj_type, obj_owner, obj_name)
/

rem table to store the information about the objects involved while executing
rem a redefinition's rollback operation
rem this table should always be identical to redef_object$ table
create table redef_object_backup$ as select * from redef_object$
/
rem the following index shuld be identical to index, i_redef_object$
create index i_redef_object_backup$ on
 redef_object_backup$(redef_id, obj_type, obj_owner, obj_name)
/

rem table to store the dependent objects that could not be cloned during the
rem online redefinition
create table redef_dep_error$(
  redef_id       integer            not null,             /* redefinition id */
  obj_type       integer            not null,                 /* object type */
  obj_owner      varchar2("M_IDEN") not null,       /* original object owner */
  obj_name       varchar2("M_IDEN") not null,        /* original object name */
  bt_owner       varchar2("M_IDEN"),                     /* base table owner */
  bt_name        varchar2("M_IDEN"),                      /* base table name */
  ddl_txt        clob,                                         /* ddl string */
  err_no         INTEGER,                                    /* error number */
  err_txt        varchar2(1000)                                /* error text */
)  
/
create index i_redef_dep_error$ on
 redef_dep_error$(redef_id, obj_type, obj_owner, obj_name)
/
CREATE TABLE redef_status$(
   redef_id       INTEGER             not null,           /* redefinition id */
   prev_operation VARCHAR2("M_IDEN")  not null,           /* the previous op */
   obj_owner      VARCHAR2("M_IDEN")  not null,  /* owner of redefined table */ 
   obj_name       VARCHAR2("M_IDEN")  not null,         /* name of partition */ 
   status         VARCHAR2("M_IDEN")  not null,     /* status of previous Op */
   restartable    VARCHAR2(1)         not null,  /* can restart previous op? */
   err_no         INTEGER,                                   /* error number */
   err_txt        varchar2(1000),                              /* error text */
   action         varchar2(400)                                    /* action */
)
/
create index i_redef_status$ on
       redef_status$(redef_id)
/

rem table to store the statistics information for online redefinition
create table redef_track$(
  redef#            number not null primary key,  /* total # of redefinition */
  finish_redef#     number,            /* total # of successful redefinition */
  abort_redef#      number,               /* total # of aborted redefinition */
  pk_redef#         number,              /* total # of PK-based redefinition */
  rowid_redef#      number,           /* total # of rowid-based redefinition */
  part_redef#       number,       /* total # of partition-based redefinition */
  batch_redef#      number,                 /* total # of batch redefinition */
  vpd_auto#         number,         /* total # of auto copy VPD redefinition */
  vpd_manual#       number,       /* total # of manual copy VPD redefinition */
  last_redef_time   date                           /* last redefinition time */
)
/ 
insert into redef_track$ (redef#, finish_redef#, abort_redef#, pk_redef#, rowid_redef#,
  part_redef#, batch_redef#,vpd_auto#, vpd_manual#, last_redef_time)
  values(0, 0, 0, 0, 0, 0, 0, 0,  0, null)
/

REM table to store usage statistics for MV refresh
create table mv_refresh_usage_stats$(
  mv_type#        varchar2(10) not null,
  refresh_method# varchar2(10) not null,
  refresh_mode#   varchar2(10) not null,
  out_of_place#   varchar2(3)  not null,
  atomic#         varchar2(3)  not null,
  count#          number       not null,
  seq#            number       not null
)
/

REM insert rows for all combinations along the following dimensions
REM 1. MV type: MAV, MJV, MAV1, OTHER
REM 2. Refresh method: FAST, PCT, COMPLETE, SYNC
REM 3. Refresh mode: ON-DEMAND, ON-COMMIT
REM 4. OUT-OF-PLACE(YES), IN-PLACE(NO)
REM 5. ATOMIC(YES), NON-ATOMIC(NO)

REM 1
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV', 'FAST', 'ON_DEMAND', 'YES', 'YES', 0, 0)
/

REM 2
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV', 'FAST', 'ON_DEMAND', 'YES', 'NO', 0, 0)
/

REM 3
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV', 'FAST', 'ON_DEMAND', 'NO', 'YES', 0, 0)
/

REM 4
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV', 'FAST', 'ON_DEMAND', 'NO', 'NO', 0, 0)
/

REM 5
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV', 'FAST', 'ON_COMMIT', 'YES', 'YES', 0, 0)
/

REM 6
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV', 'FAST', 'ON_COMMIT', 'YES', 'NO', 0, 0)
/

REM 7
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV', 'FAST', 'ON_COMMIT', 'NO', 'YES', 0, 0)
/

REM 8
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV', 'FAST', 'ON_COMMIT', 'NO', 'NO', 0, 0)
/

REM 9
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV', 'PCT', 'ON_DEMAND', 'YES', 'YES', 0, 0)
/

REM 10
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV', 'PCT', 'ON_DEMAND', 'YES', 'NO', 0, 0)
/

REM 11
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV', 'PCT', 'ON_DEMAND', 'NO', 'YES', 0, 0)
/

REM 12
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV', 'PCT', 'ON_DEMAND', 'NO', 'NO', 0, 0)
/

REM 13
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV', 'PCT', 'ON_COMMIT', 'YES', 'YES', 0, 0)
/

REM 14
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV', 'PCT', 'ON_COMMIT', 'YES', 'NO', 0, 0)
/

REM 15
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV', 'PCT', 'ON_COMMIT', 'NO', 'YES', 0, 0)
/

REM 16
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV', 'PCT', 'ON_COMMIT', 'NO', 'NO', 0, 0)
/

REM 17
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV', 'COMPLETE', 'ON_DEMAND', 'YES', 'YES', 0, 0)
/

REM 18
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV', 'COMPLETE', 'ON_DEMAND', 'YES', 'NO', 0, 0)
/

REM 19
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV', 'COMPLETE', 'ON_DEMAND', 'NO', 'YES', 0, 0)
/

REM 20
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV', 'COMPLETE', 'ON_DEMAND', 'NO', 'NO', 0, 0)
/

REM 21
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV', 'COMPLETE', 'ON_COMMIT', 'YES', 'YES', 0, 0)
/

REM 22
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV', 'COMPLETE', 'ON_COMMIT', 'YES', 'NO', 0, 0)
/

REM 23
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV', 'COMPLETE', 'ON_COMMIT', 'NO', 'YES', 0, 0)
/

REM 24
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV', 'COMPLETE', 'ON_COMMIT', 'NO', 'NO', 0, 0)
/

REM 25
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MJV', 'FAST', 'ON_DEMAND', 'YES', 'YES', 0, 0)
/

REM 26
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MJV', 'FAST', 'ON_DEMAND', 'YES', 'NO', 0, 0)
/

REM 27
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MJV', 'FAST', 'ON_DEMAND', 'NO', 'YES', 0, 0)
/

REM 28
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MJV', 'FAST', 'ON_DEMAND', 'NO', 'NO', 0, 0)
/

REM 29
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MJV', 'FAST', 'ON_COMMIT', 'YES', 'YES', 0, 0)
/

REM 30
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MJV', 'FAST', 'ON_COMMIT', 'YES', 'NO', 0, 0)
/

REM 31
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MJV', 'FAST', 'ON_COMMIT', 'NO', 'YES', 0, 0)
/

REM 32
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MJV', 'FAST', 'ON_COMMIT', 'NO', 'NO', 0, 0)
/

REM 33
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MJV', 'PCT', 'ON_DEMAND', 'YES', 'YES', 0, 0)
/

REM 34
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MJV', 'PCT', 'ON_DEMAND', 'YES', 'NO', 0, 0)
/

REM 35
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MJV', 'PCT', 'ON_DEMAND', 'NO', 'YES', 0, 0)
/

REM 36
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MJV', 'PCT', 'ON_DEMAND', 'NO', 'NO', 0, 0)
/

REM 37
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MJV', 'PCT', 'ON_COMMIT', 'YES', 'YES', 0, 0)
/

REM 38
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MJV', 'PCT', 'ON_COMMIT', 'YES', 'NO', 0, 0)
/

REM 39
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MJV', 'PCT', 'ON_COMMIT', 'NO', 'YES', 0, 0)
/

REM 40
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MJV', 'PCT', 'ON_COMMIT', 'NO', 'NO', 0, 0)
/

REM 41
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MJV', 'COMPLETE', 'ON_DEMAND', 'YES', 'YES', 0, 0)
/

REM 42
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MJV', 'COMPLETE', 'ON_DEMAND', 'YES', 'NO', 0, 0)
/

REM 43
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MJV', 'COMPLETE', 'ON_DEMAND', 'NO', 'YES', 0, 0)
/

REM 44
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MJV', 'COMPLETE', 'ON_DEMAND', 'NO', 'NO', 0, 0)
/

REM 45
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MJV', 'COMPLETE', 'ON_COMMIT', 'YES', 'YES', 0, 0)
/

REM 46
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MJV', 'COMPLETE', 'ON_COMMIT', 'YES', 'NO', 0, 0)
/

REM 47
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MJV', 'COMPLETE', 'ON_COMMIT', 'NO', 'YES', 0, 0)
/

REM 48
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MJV', 'COMPLETE', 'ON_COMMIT', 'NO', 'NO', 0, 0)
/

REM 49
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV1', 'FAST', 'ON_DEMAND', 'YES', 'YES', 0, 0)
/

REM 50
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV1', 'FAST', 'ON_DEMAND', 'YES', 'NO', 0, 0)
/

REM 51
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV1', 'FAST', 'ON_DEMAND', 'NO', 'YES', 0, 0)
/

REM 52
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV1', 'FAST', 'ON_DEMAND', 'NO', 'NO', 0, 0)
/

REM 53
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV1', 'FAST', 'ON_COMMIT', 'YES', 'YES', 0, 0)
/

REM 54
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV1', 'FAST', 'ON_COMMIT', 'YES', 'NO', 0, 0)
/

REM 55
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV1', 'FAST', 'ON_COMMIT', 'NO', 'YES', 0, 0)
/

REM 56
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV1', 'FAST', 'ON_COMMIT', 'NO', 'NO', 0, 0)
/

REM 57
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV1', 'PCT', 'ON_DEMAND', 'YES', 'YES', 0, 0)
/

REM 58
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV1', 'PCT', 'ON_DEMAND', 'YES', 'NO', 0, 0)
/

REM 59
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV1', 'PCT', 'ON_DEMAND', 'NO', 'YES', 0, 0)
/

REM 60
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV1', 'PCT', 'ON_DEMAND', 'NO', 'NO', 0, 0)
/

REM 61
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV1', 'PCT', 'ON_COMMIT', 'YES', 'YES', 0, 0)
/

REM 62
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV1', 'PCT', 'ON_COMMIT', 'YES', 'NO', 0, 0)
/

REM 63
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV1', 'PCT', 'ON_COMMIT', 'NO', 'YES', 0, 0)
/

REM 64
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV1', 'PCT', 'ON_COMMIT', 'NO', 'NO', 0, 0)
/

REM 65
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV1', 'COMPLETE', 'ON_DEMAND', 'YES', 'YES', 0, 0)
/

REM 66
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV1', 'COMPLETE', 'ON_DEMAND', 'YES', 'NO', 0, 0)
/

REM 67
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV1', 'COMPLETE', 'ON_DEMAND', 'NO', 'YES', 0, 0)
/

REM 68
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV1', 'COMPLETE', 'ON_DEMAND', 'NO', 'NO', 0, 0)
/

REM 69
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV1', 'COMPLETE', 'ON_COMMIT', 'YES', 'YES', 0, 0)
/

REM 70
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV1', 'COMPLETE', 'ON_COMMIT', 'YES', 'NO', 0, 0)
/

REM 71
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV1', 'COMPLETE', 'ON_COMMIT', 'NO', 'YES', 0, 0)
/

REM 72
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV1', 'COMPLETE', 'ON_COMMIT', 'NO', 'NO', 0, 0)
/

REM 73
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('OTHER', 'FAST', 'ON_DEMAND', 'YES', 'YES', 0, 0)
/

REM 74
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('OTHER', 'FAST', 'ON_DEMAND', 'YES', 'NO', 0, 0)
/

REM 75
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('OTHER', 'FAST', 'ON_DEMAND', 'NO', 'YES', 0, 0)
/

REM 76
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('OTHER', 'FAST', 'ON_DEMAND', 'NO', 'NO', 0, 0)
/

REM 77
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('OTHER', 'FAST', 'ON_COMMIT', 'YES', 'YES', 0, 0)
/

REM 78
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('OTHER', 'FAST', 'ON_COMMIT', 'YES', 'NO', 0, 0)
/

REM 79
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('OTHER', 'FAST', 'ON_COMMIT', 'NO', 'YES', 0, 0)
/

REM 80
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('OTHER', 'FAST', 'ON_COMMIT', 'NO', 'NO', 0, 0)
/

REM 81
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('OTHER', 'PCT', 'ON_DEMAND', 'YES', 'YES', 0, 0)
/

REM 82
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('OTHER', 'PCT', 'ON_DEMAND', 'YES', 'NO', 0, 0)
/

REM 83
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('OTHER', 'PCT', 'ON_DEMAND', 'NO', 'YES', 0, 0)
/

REM 84
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('OTHER', 'PCT', 'ON_DEMAND', 'NO', 'NO', 0, 0)
/

REM 85
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('OTHER', 'PCT', 'ON_COMMIT', 'YES', 'YES', 0, 0)
/

REM 86
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('OTHER', 'PCT', 'ON_COMMIT', 'YES', 'NO', 0, 0)
/

REM 87
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('OTHER', 'PCT', 'ON_COMMIT', 'NO', 'YES', 0, 0)
/

REM 88
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('OTHER', 'PCT', 'ON_COMMIT', 'NO', 'NO', 0, 0)
/

REM 89
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('OTHER', 'COMPLETE', 'ON_DEMAND', 'YES', 'YES', 0, 0)
/

REM 90
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('OTHER', 'COMPLETE', 'ON_DEMAND', 'YES', 'NO', 0, 0)
/

REM 91
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('OTHER', 'COMPLETE', 'ON_DEMAND', 'NO', 'YES', 0, 0)
/

REM 92
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('OTHER', 'COMPLETE', 'ON_DEMAND', 'NO', 'NO', 0, 0)
/

REM 93
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('OTHER', 'COMPLETE', 'ON_COMMIT', 'YES', 'YES', 0, 0)
/

REM 94
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('OTHER', 'COMPLETE', 'ON_COMMIT', 'YES', 'NO', 0, 0)
/

REM 95
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('OTHER', 'COMPLETE', 'ON_COMMIT', 'NO', 'YES', 0, 0)
/

REM 96
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('OTHER', 'COMPLETE', 'ON_COMMIT', 'NO', 'NO', 0, 0)
/

REM 97
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV', 'SYNC', 'ON_DEMAND', 'NO', 'NO', 0, 0)
/

REM 98
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MJV', 'SYNC', 'ON_DEMAND', 'NO', 'NO', 0, 0)
/

REM 99
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('MAV1', 'SYNC', 'ON_DEMAND', 'NO', 'NO', 0, 0)
/

REM 100
insert into mv_refresh_usage_stats$
  (mv_type#, refresh_method#, refresh_mode#, out_of_place#, atomic#, count#, seq#) 
values 
  ('OTHER', 'SYNC', 'ON_DEMAND', 'NO', 'NO', 0, 0)
/

REM Bug 26289288 : Persistent state of Private Temp Table(PTT) feature
REM Notes:
REM - 'status' column can have one of the following values
REM     #define KXTT_PTT_NOT_DETERMINED 0
REM     #define KXTT_PTT_ENABLED        1
REM     #define KXTT_PTT_DISABLED       2
REM     #define KXTT_PTT_SQLFAILED      3
REM - 'Database open' notifier, kxttPttValidate() will validate and update this
REM  table accordingly
REM - Default PTT prefix will be ORA$PTT_ (all in upcase)
CREATE TABLE ptt_feature$
(
  track_time    TIMESTAMP,
  status        NUMBER NOT NULL,
  prefix_value  VARCHAR2("M_IDEN") NOT NULL,
  spare1        NUMBER,
  spare2        VARCHAR2("M_IDEN") 
)
/
insert into ptt_feature$ values(systimestamp, 0, 'ORA$PTT_', NULL, NULL)
/
