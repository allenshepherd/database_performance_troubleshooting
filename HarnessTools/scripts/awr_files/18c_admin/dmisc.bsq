Rem    MODIFIED   (MM/DD/YY)
Rem    raeburns    11/10/17 - Bug 27103422: Extend banner_full to 128
Rem    raeburns    08/30/17 - Bug 26255427: Add new registry$ columns for FULL
Rem                           RU version
Rem    nrcorcor    05/29/15 - Bug 20814955 - crash extending lost write extent.
Rem    hvieyra     05/11/15 - Auto Upgrade resume functionality - Bug fix 20688203
Rem    cmlim       03/24/15 - bug 20756240: support long identifiers in
Rem                           validation procedure names 
Rem    krajaman    09/12/14 - Created

REM This was in catcr.sql

CREATE TABLE registry$ (
             cid      VARCHAR2(30),                 /* component identifier */
             cname    VARCHAR2(255),                      /* component name */
             schema#  NUMBER NOT NULL,             /* user# of schema owner */
             invoker# NUMBER NOT NULL,           /* user# of script invoker */
             version  VARCHAR2(30),             /* component version loaded */
             edition  VARCHAR2(30),                              /* edition */
             status   NUMBER NOT NULL,                  /* component status */
                                                         /* 0 = INVALID     */
                                                         /* 1 = VALID       */
                                                         /* 2 = LOADING     */
                                                         /* 3 = LOADED      */
                                                         /* 4 = UPGRADING   */
                                                         /* 5 = UPGRADED    */
                                                         /* 6 = DOWNGRADING */
                                                         /* 7 = DOWNGRADED  */
                                                         /* 8 = REMOVING    */
                                                         /* 9 = OPTION OFF  */
                                                         /* 10 = NO SCRIPT  */
                                                         /* 99 = REMOVED    */
             flags    NUMBER NOT NULL,        /* additional component flags */
                                                   /* 0x01 STARTUP REQUIRED */
             modified DATE,                       /* last modified datetime */
             pid      VARCHAR2(30),          /* parent component identifier */
             banner   VARCHAR2(80),             /* component display banner */
             vproc    VARCHAR2(128),                /* validation procedure */
             date_invalid       DATE,              /* last INVALID datetime */
             date_valid         DATE,                /* last VALID datetime */
             date_loading       DATE,              /* last LOADING datetime */
             date_loaded        DATE,               /* last LOADED datetime */
             date_upgrading     DATE,            /* last UPGRADING datetime */
             date_upgraded      DATE,             /* last UPGRADED datetime */
             date_downgrading   DATE,          /* last DOWNGRADING datetime */
             date_downgraded    DATE,           /* last DOWNGRADED datetime */
             date_removing      DATE,             /* last REMOVING datetime */
             date_removed       DATE,              /* last REMOVED datetime */
             date_optionoff     DATE,      /* Component OPTION OFF datetime */
             namespace          VARCHAR2(30),        /* component namespace */
             org_version        VARCHAR2(30),     /* original loaded version */
             prv_version        VARCHAR2(30),            /* previous version */
             signature          RAW(20),              /* component signature */
             version_full       VARCHAR2(30),             /* full RU version */
             org_version_full   VARCHAR2(30),    /* original full RU version */
             prv_version_full   VARCHAR2(30),    /* previous full RU version */
             banner_full        VARCHAR2(128),             /* full RU banner */
             CONSTRAINT registry_pk  PRIMARY KEY (namespace, cid),
             CONSTRAINT registry_parent_fk FOREIGN KEY (namespace, pid)
                        REFERENCES registry$ (namespace, cid)
                        ON DELETE CASCADE)
/

CREATE TABLE registry$schemas (
             cid         VARCHAR2(30),              /* component identifier */
             namespace   VARCHAR2(30),               /* component namespace */
             schema#     NUMBER,                      /* ancillary schema # */
             CONSTRAINT registry_schema_pk PRIMARY KEY
                        (namespace, cid, schema#),
             CONSTRAINT registry_schema_fk FOREIGN KEY (namespace, cid)
                        REFERENCES registry$ (namespace, cid)
                        ON DELETE CASCADE)
/

CREATE TABLE registry$log (
             cid         VARCHAR2(30),              /* component identifier */
             namespace   VARCHAR2(30),               /* component namespace */
             operation   NUMBER NOT NULL,              /* current operation */
                                                         /*-1 = START       */
                                                         /* 0 = INVALID     */
                                                         /* 1 = VALID       */
                                                         /* 2 = LOADING     */
                                                         /* 3 = LOADED      */
                                                         /* 4 = UPGRADING   */
                                                         /* 5 = UPGRADED    */
                                                         /* 6 = DOWNGRADING */
                                                         /* 7 = DOWNGRADED  */
                                                         /* 8 = REMOVING    */
                                                         /* 9 = OPTION OFF  */
                                                         /* 10 = NO SCRIPT  */
                                                         /* 99 = REMOVED    */
                                                        /* 100 = ERROR      */
             optime      TIMESTAMP,                  /* operation timestamp */
             errmsg      VARCHAR2(1000)  /* error message text from SQL*Plus */
             )
/

Rem
Rem
Rem ------------------------------------------------------------------------
Rem REGISTRY$UPG_SUMMARY table
Rem
Rem Summary progress of the upgrade used by DBUA
Rem
Rem Create DBUA Summary table in the ROOT only
Rem PDBs are object linked to the table.
Rem ------------------------------------------------------------------------
Rem
Rem

CREATE TABLE sys.registry$upg_summary
                (con_id      NUMBER,          /* Con id */
                 con_name    VARCHAR2(128),   /* Container Name */
                 cid         VARCHAR2(30),    /* Component id */
                 progress    VARCHAR2(1024),  /* DBUA Timestamp progress */
                 errcnt      NUMBER,          /* Error Count */
                 starttime   TIMESTAMP,       /* Start of phase time */
                 endtime     TIMESTAMP,       /* End of phase time */
                 reportname  VARCHAR2(2000)   /* Summary Report Name */
                )
/

Rem
Rem ------------------------------------------------------------------------
Rem REGISTRY$ERROR table
Rem
Rem Contains error messages for components during upgrade(if errors occur)
Rem ------------------------------------------------------------------------
Rem
Rem

CREATE TABLE sys.registry$error(username   VARCHAR(256),
                                timestamp  TIMESTAMP,
                                script     VARCHAR(1024),
                                identifier VARCHAR(256),
                                message    CLOB,
                                statement  CLOB)
/

Rem
Rem ------------------------------------------------------------------------
Rem REGISTRY$HISTORY table
Rem
Rem Contains a time-stamped entry for each upgrade/downgrade performed 
Rem and for each CPU applied to the database.
Rem ------------------------------------------------------------------------

CREATE TABLE registry$history (
             action_time     TIMESTAMP,                     /* time stamp */
             action          VARCHAR2(30),              /* name of action */
             namespace       VARCHAR2(30),           /* upgrade namespace */
             version         VARCHAR(30),               /* server version */
             id              NUMBER,                   /* CPU or Patch ID */
             comments        VARCHAR2(255),                   /* comments */
             bundle_series   VARCHAR2(30)                /* bundle series */
             )
/

Rem
Rem ------------------------------------------------------------------------
Rem REGISTRY$PROGRESS table
Rem
Rem Contains value/step entry for each progress action taken during upgrade
Rem 
Rem ------------------------------------------------------------------------

CREATE TABLE registry$progress (
             cid         VARCHAR2(30),              /* component identifier */
             namespace   VARCHAR2(30),               /* component namespace */
             action      VARCHAR2(255),                  /* progress action */
             value       VARCHAR2(255),                   /* progress value */
             step        NUMBER,                         /* progress number */
             action_time TIMESTAMP,                            /* timestamp */
             CONSTRAINT registry_progress_pk  PRIMARY KEY 
                        (cid, namespace, action),
             CONSTRAINT registry_progress_fk FOREIGN KEY (cid, namespace)
                        REFERENCES registry$ (cid,namespace) 
                        ON DELETE CASCADE
             )
/

Rem
Rem ------------------------------------------------------------------------
Rem REGISTRY$DEPENDENCIES table
Rem
Rem Contains component dependency information.
Rem 
Rem ------------------------------------------------------------------------

CREATE TABLE registry$dependencies (
             cid           VARCHAR2(30),            /* component identifier */
             namespace     VARCHAR2(30),             /* component namespace */
             req_cid       VARCHAR2(30),   /* required component identifier */
             req_namespace VARCHAR2(30),    /* required component namespace */
             CONSTRAINT dependencies_pk  PRIMARY KEY 
                        (namespace,cid,req_namespace,req_cid),
             CONSTRAINT dependencies_fk FOREIGN KEY (namespace,cid)
                        REFERENCES registry$ (namespace,cid) 
                        ON DELETE CASCADE,
             CONSTRAINT dependencies_req_fk FOREIGN KEY (req_namespace,req_cid)
                        REFERENCES registry$ (namespace,cid) 
                        ON DELETE CASCADE
             )
/

Rem
Rem ------------------------------------------------------------------------
Rem REGISTRY$DATABASE table
Rem
Rem Contains database specific information such as platform id, 
Rem platform name, edition 
Rem ------------------------------------------------------------------------
Rem
Rem

CREATE TABLE registry$database( 
             platform_id   NUMBER,        /* database platform id */
             platform_name VARCHAR2(101), /* database platform name */
             edition       VARCHAR2(30),  /* database edition */
             tz_version    NUMBER         /* timezone file version */
             )
/

Rem
Rem ------------------------------------------------------------------------
Rem REGISTRY$UPG_RESUME table
Rem
Rem Contains phases upgrade related information 
Rem
Rem ------------------------------------------------------------------------
Rem
Rem

CREATE TABLE registry$upg_resume(
             version   VARCHAR2(30),    /* database version  */
             phaseno   NUMBER, 		/* upgrade phase number*/
             errorcnt  NUMBER,  	/* errors during the phase*/
             starttime  TIMESTAMP(6),    /* phase start time */
             endtime   TIMESTAMP(6)     /* phase end time   */
             )
/


REM This was in cattrans.sql
REM Table that stores the transformations

create table transformations$(
  transformation_id    number        not null primary key,
  owner                varchar2(128)  not null,
  name                 varchar2(128)  not null,
  from_schema          varchar2(128),
  from_type            varchar2(128),
  from_toid            raw(16)       not null,
  from_version         number        not null,
  to_schema            varchar2(128),
  to_type              varchar2(256),
  to_toid              raw(16)       not null,
  to_version           number        not null)
/

REM Table that stores the attribute mappings
create table attribute_transformations$(
  transformation_id    number,
                          constraint attribute_transformations_fk
                          foreign key (transformation_id)
                          references transformations$ on delete cascade,
  attribute_number     number,
                          constraint attribute_transformations_pk
                          primary key(transformation_id, attribute_number),
  sql_expression       varchar2(4000),
  xsl_transformation   CLOB)
/

REM Sequence for transformation id

CREATE SEQUENCE sys.aq$_trans_sequence START WITH 1
/

Rem ===========================================================================
Rem      New Lost Write feature - bug 13539672
Rem
Rem      For the 12.2 Server and higher these system tables track the
Rem      offsets in the shadow tablespace/datafile that contain SCNs of blocks
Rem      from other datafiles that were written. The idea is that upon
Rem      reading a block in any other datafile we can compare the SCN
Rem      in that block with the SCN that was stored in the shadow datafile
Rem      and if the SCN in the block is less than the shadow datafile's
Rem      copy this indicates a lost write.
Rem
Rem      So for each datafile in the system we need to track its starting
Rem      offset in the shadow datafile so we can compute the block that the
Rem      SCN can be found on.
Rem
Rem      These tables are always created although they will be empty if
Rem      the new lost write feature is not being used.
Rem
Rem      DO NOT PUT TABLES in the "SYS$_LOST..." bigfile tablespace(s).
Rem      sys$_lost... are where the shadow datafiles reside - we presume
Rem      that all space in the shadow datafile is available for
Rem      block SCN tracking. SYS$_LOST... is the recommended name for
Rem      new lost write tablespaces. Use of this prefix is optional.
Rem
Rem      new_lost_write_extents$ initially has only one entry per
Rem         shadow tablespace since there is only one file allowed in a
Rem         bigfile tablespace. After some datafile creations and deletions
Rem         this table may have multiple free extent entries. Each row
Rem         describes a free extent in a shadow datafile.
Rem
Rem      new_lost_write_datafiles$ contains the association between
Rem        the extent allocated in the shadow datafile to a
Rem        datafile being tracked.
Rem
Rem      new_lost_write_shadows$ describes all the lost write shadow
Rem        tablespaces. These are bigfile tablespaces so have only one
Rem        datafile. There are typically only a few of these.
Rem
Rem      The following SQL command example causes these tables to be updated:
Rem
Rem     create bigfile tablespace sys$_lost... datafile 'shadow_datafile'
Rem        size 4500000 blocksize 8K nologging lost write protection;
Rem
Rem     Since shadow tablespaces are bigfile they only have one datafile
Rem     the rfn is fixed.
Rem
Rem     current_status is either "enabled" or "suspended". Enabled is only
Rem     really active if lost write protection is turned on for the PDB.
Rem     To suspend lost write protection for a datafile use SQL command:
Rem     alter database datafile <'datafilename'> suspend lost write protection;
Rem     If you suspend lost write protection you must enable it; restarting
Rem     the Server will not enable it.
Rem
Rem ==========================================================================
CREATE TABLE new_lost_write_datafiles$
(
   datafile_tsid_tracked     NUMBER,
   datafile_rfn_tracked        NUMBER,
   shadow_datafile_tsid        NUMBER,
   shadow_datafile_rfn         NUMBER,
   shadow_datafile_offset      NUMBER,
   number_of_blocks_allocated  NUMBER, /* not 2K blocksize - real blocks */
   datafile_current_status     VARCHAR2(10) NOT NULL
  )
  TABLESPACE sysaux
/
CREATE UNIQUE INDEX i_datafile_new_lost_wrt$_pkey ON
    new_lost_write_datafiles$ (datafile_tsid_tracked, datafile_rfn_tracked)
 TABLESPACE sysaux
/
Rem =========================================================================
Rem      new_lost_write_extents$ contains a list of free extents in all the
Rem      shadow datafiles defined. The number of blocks is always in units of
Rem      2K size blocks so that shadow tablespaces can be created anywhere
Rem      with different block sizes.
Rem      Note that we presume each 2K block has a block header/trailer - so
Rem      for an 8K block we are actually throwing away the space for 3
Rem      headers since we actually only have 1 header.
Rem
Rem      Blocks are given out in multiples of 16 2K blocks, so that the
Rem      smallest extent given out is 32K.
Rem =========================================================================
CREATE TABLE new_lost_write_extents$
(
   extent_datafile_rfn         NUMBER,  /* set to 0 if no shadow datafile   */
   extent_datafile_tsid        NUMBER,  /* tablespace ID                    */
   extent_start                NUMBER,  /* start of this free extent */
   extent_length_blocks_2K     NUMBER,  /* num of blocks in this free extent -
                                         * using 2K blocks - always a multiple
                                         * of 16 */
   extent_next_block           NUMBER   /* next block after this extent; used
                                         * for combining free extents */
   )
   TABLESPACE sysaux
/
CREATE INDEX i_new_lost_write_extents$ ON
    new_lost_write_extents$ (extent_length_blocks_2K)
 TABLESPACE sysaux
/
Rem  We could also create indexes on extent_start/afn and
Rem  extent_next_block/afn since we search for these.
Rem ========================================================================
Rem      new_lost_write_shadows$ describes all the lost write shadow
Rem      tablespaces. These are bigfile tablespaces so have only one
Rem      datafile. There are typically few of these.
Rem
Rem      Note that the shadow_number_blocks_alloc is the real number of
Rem      blocks allocated - not in units of 2K blocksize as in the table
Rem      new_lost_write_extents$.
Rem ========================================================================
CREATE TABLE new_lost_write_shadows$
(
   shadow_datafile_rfn         NUMBER,
   shadow_datafile_tsid        NUMBER,  /* tablespace ID                      */
   shadow_number_blocks_alloc  NUMBER,  /* total number of blocks currently
                                         * in file including the unused bitmap
                                         * not 2K blocksize */
   shadow_first_free_block     NUMBER,  /* first available block; after bitmap*/
   shadow_block_size_bytes     NUMBER,  /* block size in this tablespace      */
   shadow_recs_per_block       NUMBER   /* number of records per block        */
   )
   TABLESPACE sysaux
/
